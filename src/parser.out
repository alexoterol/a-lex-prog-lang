Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASYNC
    AWAIT
    CATCH
    DEFER
    DIDSET
    DO
    ENUM
    EXTENSION
    IMPORT
    INTERNAL
    PRIVATE
    PROTOCOL
    PUBLIC
    SEMI_COLON
    SET
    SOME
    STATIC
    STRUCT
    THROW
    THROWS
    TRY
    WILLSET

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> variable_declaration
Rule 5     statement -> assignment
Rule 6     statement -> for_statement
Rule 7     statement -> if_statement
Rule 8     statement -> guard_statement
Rule 9     statement -> while_statement
Rule 10    statement -> switch_statement
Rule 11    statement -> function_declaration
Rule 12    statement -> function_call_statement
Rule 13    statement -> class_declaration
Rule 14    statement -> expression_statement
Rule 15    statement -> return_statement
Rule 16    statement -> break_statement
Rule 17    statement -> continue_statement
Rule 18    statement -> NEWLINE
Rule 19    expression_statement -> expression
Rule 20    variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression
Rule 21    variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression
Rule 22    variable_declaration -> LET IDENTIFIER ASSIGN expression
Rule 23    variable_declaration -> VAR IDENTIFIER ASSIGN expression
Rule 24    variable_declaration -> LET IDENTIFIER COLON type_annotation
Rule 25    variable_declaration -> VAR IDENTIFIER COLON type_annotation
Rule 26    variable_declaration -> LET IDENTIFIER COLON tuple_type
Rule 27    variable_declaration -> VAR IDENTIFIER COLON tuple_type
Rule 28    type_annotation -> TYPE_INT
Rule 29    type_annotation -> TYPE_DOUBLE
Rule 30    type_annotation -> TYPE_BOOL
Rule 31    type_annotation -> TYPE_STRING
Rule 32    type_annotation -> array_type
Rule 33    type_annotation -> dictionary_type
Rule 34    type_annotation -> optional_type
Rule 35    type_annotation -> tuple_type
Rule 36    type_annotation -> IDENTIFIER
Rule 37    optional_type -> TYPE_INT QUESTION
Rule 38    optional_type -> TYPE_DOUBLE QUESTION
Rule 39    optional_type -> TYPE_BOOL QUESTION
Rule 40    optional_type -> TYPE_STRING QUESTION
Rule 41    array_type -> LBRACKET type_annotation RBRACKET
Rule 42    expression -> LBRACKET array_elements RBRACKET
Rule 43    expression -> LBRACKET RBRACKET
Rule 44    array_elements -> array_elements COMMA expression
Rule 45    array_elements -> expression
Rule 46    expression -> expression LBRACKET expression RBRACKET
Rule 47    dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET
Rule 48    expression -> LBRACKET dictionary_pairs RBRACKET
Rule 49    expression -> LBRACKET COLON RBRACKET
Rule 50    dictionary_pairs -> dictionary_pairs COMMA dictionary_pair
Rule 51    dictionary_pairs -> dictionary_pair
Rule 52    dictionary_pair -> expression COLON expression
Rule 53    tuple_type -> LPAREN tuple_type_elements RPAREN
Rule 54    tuple_type_elements -> tuple_type_elements COMMA tuple_type_element
Rule 55    tuple_type_elements -> tuple_type_element
Rule 56    tuple_type_element -> IDENTIFIER COLON type_annotation
Rule 57    tuple_type_element -> type_annotation
Rule 58    expression -> LPAREN tuple_elements RPAREN
Rule 59    tuple_elements -> tuple_elements COMMA tuple_element
Rule 60    tuple_elements -> tuple_element
Rule 61    tuple_element -> IDENTIFIER COLON expression
Rule 62    tuple_element -> expression
Rule 63    expression -> expression DOT INT_LITERAL
Rule 64    expression -> expression DOT IDENTIFIER
Rule 65    assignment -> lvalue ASSIGN expression
Rule 66    assignment -> lvalue PLUS_ASSIGN expression
Rule 67    assignment -> lvalue MINUS_ASSIGN expression
Rule 68    assignment -> lvalue TIMES_ASSIGN expression
Rule 69    assignment -> lvalue DIV_ASSIGN expression
Rule 70    assignment -> lvalue MOD_ASSIGN expression
Rule 71    lvalue -> IDENTIFIER
Rule 72    lvalue -> SELF DOT IDENTIFIER
Rule 73    lvalue -> lvalue DOT IDENTIFIER
Rule 74    lvalue -> lvalue LBRACKET expression RBRACKET
Rule 75    expression -> expression PLUS expression
Rule 76    expression -> expression MINUS expression
Rule 77    expression -> expression TIMES expression
Rule 78    expression -> expression DIVIDE expression
Rule 79    expression -> expression MODULO expression
Rule 80    expression -> MINUS expression
Rule 81    expression -> PLUS expression
Rule 82    expression -> expression AND expression
Rule 83    expression -> expression OR expression
Rule 84    expression -> NOT expression
Rule 85    expression -> expression EQ expression
Rule 86    expression -> expression NE expression
Rule 87    expression -> expression GT expression
Rule 88    expression -> expression LT expression
Rule 89    expression -> expression GE expression
Rule 90    expression -> expression LE expression
Rule 91    expression -> expression QUESTION expression COLON expression
Rule 92    expression -> expression NIL_COALESCE expression
Rule 93    expression -> LPAREN expression RPAREN
Rule 94    expression -> INT_LITERAL
Rule 95    expression -> FLOAT_LITERAL
Rule 96    expression -> STRING
Rule 97    expression -> TRUE
Rule 98    expression -> FALSE
Rule 99    expression -> NIL
Rule 100   expression -> IDENTIFIER
Rule 101   expression -> SELF DOT IDENTIFIER
Rule 102   expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 103   expression -> IDENTIFIER LPAREN RPAREN
Rule 104   for_statement -> for_header LBRACE statement_list RBRACE
Rule 105   for_header -> FOR IDENTIFIER IN range_expression
Rule 106   for_header -> FOR IDENTIFIER IN expression
Rule 107   range_expression -> expression CLOSED_RANGE expression
Rule 108   range_expression -> expression HALF_OPEN_RANGE expression
Rule 109   if_statement -> IF expression LBRACE statement_list RBRACE
Rule 110   if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
Rule 111   if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain
Rule 112   if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
Rule 113   else_if_chain -> else_if_chain else_if_statement
Rule 114   else_if_chain -> else_if_statement
Rule 115   else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE
Rule 116   guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE
Rule 117   while_statement -> while_header LBRACE statement_list RBRACE
Rule 118   while_header -> WHILE expression
Rule 119   break_statement -> BREAK
Rule 120   continue_statement -> CONTINUE
Rule 121   switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
Rule 122   switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
Rule 123   case_list -> case_list optional_newlines case_clause
Rule 124   case_list -> optional_newlines case_clause
Rule 125   case_clause -> CASE case_patterns COLON optional_newlines case_body
Rule 126   case_body -> statement_list
Rule 127   case_patterns -> case_patterns COMMA expression
Rule 128   case_patterns -> expression
Rule 129   default_case -> DEFAULT COLON optional_newlines case_body
Rule 130   optional_newlines -> optional_newlines NEWLINE
Rule 131   optional_newlines -> empty
Rule 132   function_declaration -> func_header LBRACE statement_list RBRACE
Rule 133   func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
Rule 134   func_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
Rule 135   func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN
Rule 136   func_header -> FUNC IDENTIFIER LPAREN RPAREN
Rule 137   parameter_list -> parameter_list COMMA parameter
Rule 138   parameter_list -> parameter
Rule 139   parameter -> IDENTIFIER COLON type_annotation
Rule 140   parameter -> IDENTIFIER COLON type_annotation ASSIGN expression
Rule 141   return_statement -> RETURN expression
Rule 142   return_statement -> RETURN
Rule 143   function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN
Rule 144   function_call_statement -> IDENTIFIER LPAREN RPAREN
Rule 145   argument_list -> argument_list COMMA expression
Rule 146   argument_list -> expression
Rule 147   class_declaration -> class_header LBRACE class_body RBRACE
Rule 148   class_header -> CLASS IDENTIFIER
Rule 149   class_body -> class_body class_member
Rule 150   class_body -> class_member
Rule 151   class_body -> empty
Rule 152   class_member -> property_declaration
Rule 153   class_member -> init_declaration
Rule 154   class_member -> method_declaration
Rule 155   class_member -> computed_property
Rule 156   class_member -> NEWLINE
Rule 157   property_declaration -> VAR IDENTIFIER COLON type_annotation
Rule 158   property_declaration -> LET IDENTIFIER COLON type_annotation
Rule 159   property_declaration -> VAR IDENTIFIER COLON tuple_type
Rule 160   property_declaration -> LET IDENTIFIER COLON tuple_type
Rule 161   computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
Rule 162   init_declaration -> init_header LBRACE statement_list RBRACE
Rule 163   init_header -> INIT LPAREN parameter_list RPAREN
Rule 164   init_header -> INIT LPAREN RPAREN
Rule 165   method_declaration -> method_header LBRACE statement_list RBRACE
Rule 166   method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
Rule 167   method_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
Rule 168   method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN
Rule 169   method_header -> FUNC IDENTIFIER LPAREN RPAREN
Rule 170   empty -> <empty>

Terminals, with rules where they appear

AND                  : 82
ARROW                : 133 134 166 167
ASSIGN               : 20 21 22 23 65 140
ASYNC                : 
AWAIT                : 
BREAK                : 119
CASE                 : 125
CATCH                : 
CLASS                : 148
CLOSED_RANGE         : 107
COLON                : 20 21 24 25 26 27 47 49 52 56 61 91 125 129 139 140 157 158 159 160 161
COMMA                : 44 50 54 59 127 137 145
CONTINUE             : 120
DEFAULT              : 129
DEFER                : 
DIDSET               : 
DIVIDE               : 78
DIV_ASSIGN           : 69
DO                   : 
DOT                  : 63 64 72 73 101
ELSE                 : 110 112 115 116
ENUM                 : 
EQ                   : 85
EXTENSION            : 
FALSE                : 98
FLOAT_LITERAL        : 95
FOR                  : 105 106
FUNC                 : 133 134 135 136 166 167 168 169
GE                   : 89
GET                  : 161
GT                   : 87
GUARD                : 116
HALF_OPEN_RANGE      : 108
IDENTIFIER           : 20 21 22 23 24 25 26 27 36 56 61 64 71 72 73 100 101 102 103 105 106 133 134 135 136 139 140 143 144 148 157 158 159 160 161 166 167 168 169
IF                   : 109 110 111 112 115
IMPORT               : 
IN                   : 105 106
INIT                 : 163 164
INTERNAL             : 
INT_LITERAL          : 63 94
LBRACE               : 104 109 110 110 111 112 112 115 116 117 121 122 132 147 161 161 162 165
LBRACKET             : 41 42 43 46 47 48 49 74
LE                   : 90
LET                  : 20 22 24 26 158 160
LPAREN               : 53 58 93 102 103 133 134 135 136 143 144 163 164 166 167 168 169
LT                   : 88
MINUS                : 76 80
MINUS_ASSIGN         : 67
MODULO               : 79
MOD_ASSIGN           : 70
NE                   : 86
NEWLINE              : 18 130 156
NIL                  : 99
NIL_COALESCE         : 92
NOT                  : 84
OR                   : 83
PLUS                 : 75 81
PLUS_ASSIGN          : 66
PRIVATE              : 
PROTOCOL             : 
PUBLIC               : 
QUESTION             : 37 38 39 40 91
RBRACE               : 104 109 110 110 111 112 112 115 116 117 121 122 132 147 161 161 162 165
RBRACKET             : 41 42 43 46 47 48 49 74
RETURN               : 141 142
RPAREN               : 53 58 93 102 103 133 134 135 136 143 144 163 164 166 167 168 169
SELF                 : 72 101
SEMI_COLON           : 
SET                  : 
SOME                 : 
STATIC               : 
STRING               : 96
STRUCT               : 
SWITCH               : 121 122
THROW                : 
THROWS               : 
TIMES                : 77
TIMES_ASSIGN         : 68
TRUE                 : 97
TRY                  : 
TYPE_BOOL            : 30 39
TYPE_DOUBLE          : 29 38
TYPE_INT             : 28 37
TYPE_STRING          : 31 40
VAR                  : 21 23 25 27 157 159 161
WHILE                : 118
WILLSET              : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 102 143 145
array_elements       : 42 44
array_type           : 32
assignment           : 5
break_statement      : 16
case_body            : 125 129
case_clause          : 123 124
case_list            : 121 122 123
case_patterns        : 125 127
class_body           : 147 149
class_declaration    : 13
class_header         : 147
class_member         : 149 150
computed_property    : 155
continue_statement   : 17
default_case         : 122
dictionary_pair      : 50 51
dictionary_pairs     : 48 50
dictionary_type      : 33
else_if_chain        : 111 112 113
else_if_statement    : 113 114
empty                : 131 151
expression           : 19 20 21 22 23 44 45 46 46 52 52 61 62 63 64 65 66 67 68 69 70 74 75 75 76 76 77 77 78 78 79 79 80 81 82 82 83 83 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 91 92 92 93 106 107 107 108 108 109 110 111 112 115 116 118 121 122 127 128 140 141 145 146
expression_statement : 14
for_header           : 104
for_statement        : 6
func_header          : 132
function_call_statement : 12
function_declaration : 11
guard_statement      : 8
if_statement         : 7
init_declaration     : 153
init_header          : 162
lvalue               : 65 66 67 68 69 70 73 74
method_declaration   : 154
method_header        : 165
optional_newlines    : 121 121 122 122 123 124 125 129 130 161 161 161 161
optional_type        : 34
parameter            : 137 138
parameter_list       : 133 135 137 163 166 168
program              : 0
property_declaration : 152
range_expression     : 105
return_statement     : 15
statement            : 2 3
statement_list       : 1 2 104 109 110 110 111 112 112 115 116 117 126 132 161 162 165
switch_statement     : 10
tuple_element        : 59 60
tuple_elements       : 58 59
tuple_type           : 26 27 35 159 160
tuple_type_element   : 54 55
tuple_type_elements  : 53 54
type_annotation      : 20 21 24 25 41 47 47 56 57 133 134 139 140 157 158 161 166 167
variable_declaration : 4
while_header         : 117
while_statement      : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    $end            reduce using rule 1 (program -> statement_list .)
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 3

    (3) statement_list -> statement .

    NEWLINE         reduce using rule 3 (statement_list -> statement .)
    LET             reduce using rule 3 (statement_list -> statement .)
    VAR             reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    GUARD           reduce using rule 3 (statement_list -> statement .)
    SWITCH          reduce using rule 3 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 3 (statement_list -> statement .)
    RETURN          reduce using rule 3 (statement_list -> statement .)
    BREAK           reduce using rule 3 (statement_list -> statement .)
    CONTINUE        reduce using rule 3 (statement_list -> statement .)
    SELF            reduce using rule 3 (statement_list -> statement .)
    FOR             reduce using rule 3 (statement_list -> statement .)
    WHILE           reduce using rule 3 (statement_list -> statement .)
    FUNC            reduce using rule 3 (statement_list -> statement .)
    CLASS           reduce using rule 3 (statement_list -> statement .)
    LBRACKET        reduce using rule 3 (statement_list -> statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement .)
    MINUS           reduce using rule 3 (statement_list -> statement .)
    PLUS            reduce using rule 3 (statement_list -> statement .)
    NOT             reduce using rule 3 (statement_list -> statement .)
    INT_LITERAL     reduce using rule 3 (statement_list -> statement .)
    FLOAT_LITERAL   reduce using rule 3 (statement_list -> statement .)
    STRING          reduce using rule 3 (statement_list -> statement .)
    TRUE            reduce using rule 3 (statement_list -> statement .)
    FALSE           reduce using rule 3 (statement_list -> statement .)
    NIL             reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)
    DEFAULT         reduce using rule 3 (statement_list -> statement .)
    CASE            reduce using rule 3 (statement_list -> statement .)


state 4

    (4) statement -> variable_declaration .

    NEWLINE         reduce using rule 4 (statement -> variable_declaration .)
    LET             reduce using rule 4 (statement -> variable_declaration .)
    VAR             reduce using rule 4 (statement -> variable_declaration .)
    IF              reduce using rule 4 (statement -> variable_declaration .)
    GUARD           reduce using rule 4 (statement -> variable_declaration .)
    SWITCH          reduce using rule 4 (statement -> variable_declaration .)
    IDENTIFIER      reduce using rule 4 (statement -> variable_declaration .)
    RETURN          reduce using rule 4 (statement -> variable_declaration .)
    BREAK           reduce using rule 4 (statement -> variable_declaration .)
    CONTINUE        reduce using rule 4 (statement -> variable_declaration .)
    SELF            reduce using rule 4 (statement -> variable_declaration .)
    FOR             reduce using rule 4 (statement -> variable_declaration .)
    WHILE           reduce using rule 4 (statement -> variable_declaration .)
    FUNC            reduce using rule 4 (statement -> variable_declaration .)
    CLASS           reduce using rule 4 (statement -> variable_declaration .)
    LBRACKET        reduce using rule 4 (statement -> variable_declaration .)
    LPAREN          reduce using rule 4 (statement -> variable_declaration .)
    MINUS           reduce using rule 4 (statement -> variable_declaration .)
    PLUS            reduce using rule 4 (statement -> variable_declaration .)
    NOT             reduce using rule 4 (statement -> variable_declaration .)
    INT_LITERAL     reduce using rule 4 (statement -> variable_declaration .)
    FLOAT_LITERAL   reduce using rule 4 (statement -> variable_declaration .)
    STRING          reduce using rule 4 (statement -> variable_declaration .)
    TRUE            reduce using rule 4 (statement -> variable_declaration .)
    FALSE           reduce using rule 4 (statement -> variable_declaration .)
    NIL             reduce using rule 4 (statement -> variable_declaration .)
    $end            reduce using rule 4 (statement -> variable_declaration .)
    RBRACE          reduce using rule 4 (statement -> variable_declaration .)
    DEFAULT         reduce using rule 4 (statement -> variable_declaration .)
    CASE            reduce using rule 4 (statement -> variable_declaration .)


state 5

    (5) statement -> assignment .

    NEWLINE         reduce using rule 5 (statement -> assignment .)
    LET             reduce using rule 5 (statement -> assignment .)
    VAR             reduce using rule 5 (statement -> assignment .)
    IF              reduce using rule 5 (statement -> assignment .)
    GUARD           reduce using rule 5 (statement -> assignment .)
    SWITCH          reduce using rule 5 (statement -> assignment .)
    IDENTIFIER      reduce using rule 5 (statement -> assignment .)
    RETURN          reduce using rule 5 (statement -> assignment .)
    BREAK           reduce using rule 5 (statement -> assignment .)
    CONTINUE        reduce using rule 5 (statement -> assignment .)
    SELF            reduce using rule 5 (statement -> assignment .)
    FOR             reduce using rule 5 (statement -> assignment .)
    WHILE           reduce using rule 5 (statement -> assignment .)
    FUNC            reduce using rule 5 (statement -> assignment .)
    CLASS           reduce using rule 5 (statement -> assignment .)
    LBRACKET        reduce using rule 5 (statement -> assignment .)
    LPAREN          reduce using rule 5 (statement -> assignment .)
    MINUS           reduce using rule 5 (statement -> assignment .)
    PLUS            reduce using rule 5 (statement -> assignment .)
    NOT             reduce using rule 5 (statement -> assignment .)
    INT_LITERAL     reduce using rule 5 (statement -> assignment .)
    FLOAT_LITERAL   reduce using rule 5 (statement -> assignment .)
    STRING          reduce using rule 5 (statement -> assignment .)
    TRUE            reduce using rule 5 (statement -> assignment .)
    FALSE           reduce using rule 5 (statement -> assignment .)
    NIL             reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)
    DEFAULT         reduce using rule 5 (statement -> assignment .)
    CASE            reduce using rule 5 (statement -> assignment .)


state 6

    (6) statement -> for_statement .

    NEWLINE         reduce using rule 6 (statement -> for_statement .)
    LET             reduce using rule 6 (statement -> for_statement .)
    VAR             reduce using rule 6 (statement -> for_statement .)
    IF              reduce using rule 6 (statement -> for_statement .)
    GUARD           reduce using rule 6 (statement -> for_statement .)
    SWITCH          reduce using rule 6 (statement -> for_statement .)
    IDENTIFIER      reduce using rule 6 (statement -> for_statement .)
    RETURN          reduce using rule 6 (statement -> for_statement .)
    BREAK           reduce using rule 6 (statement -> for_statement .)
    CONTINUE        reduce using rule 6 (statement -> for_statement .)
    SELF            reduce using rule 6 (statement -> for_statement .)
    FOR             reduce using rule 6 (statement -> for_statement .)
    WHILE           reduce using rule 6 (statement -> for_statement .)
    FUNC            reduce using rule 6 (statement -> for_statement .)
    CLASS           reduce using rule 6 (statement -> for_statement .)
    LBRACKET        reduce using rule 6 (statement -> for_statement .)
    LPAREN          reduce using rule 6 (statement -> for_statement .)
    MINUS           reduce using rule 6 (statement -> for_statement .)
    PLUS            reduce using rule 6 (statement -> for_statement .)
    NOT             reduce using rule 6 (statement -> for_statement .)
    INT_LITERAL     reduce using rule 6 (statement -> for_statement .)
    FLOAT_LITERAL   reduce using rule 6 (statement -> for_statement .)
    STRING          reduce using rule 6 (statement -> for_statement .)
    TRUE            reduce using rule 6 (statement -> for_statement .)
    FALSE           reduce using rule 6 (statement -> for_statement .)
    NIL             reduce using rule 6 (statement -> for_statement .)
    $end            reduce using rule 6 (statement -> for_statement .)
    RBRACE          reduce using rule 6 (statement -> for_statement .)
    DEFAULT         reduce using rule 6 (statement -> for_statement .)
    CASE            reduce using rule 6 (statement -> for_statement .)


state 7

    (7) statement -> if_statement .

    NEWLINE         reduce using rule 7 (statement -> if_statement .)
    LET             reduce using rule 7 (statement -> if_statement .)
    VAR             reduce using rule 7 (statement -> if_statement .)
    IF              reduce using rule 7 (statement -> if_statement .)
    GUARD           reduce using rule 7 (statement -> if_statement .)
    SWITCH          reduce using rule 7 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 7 (statement -> if_statement .)
    RETURN          reduce using rule 7 (statement -> if_statement .)
    BREAK           reduce using rule 7 (statement -> if_statement .)
    CONTINUE        reduce using rule 7 (statement -> if_statement .)
    SELF            reduce using rule 7 (statement -> if_statement .)
    FOR             reduce using rule 7 (statement -> if_statement .)
    WHILE           reduce using rule 7 (statement -> if_statement .)
    FUNC            reduce using rule 7 (statement -> if_statement .)
    CLASS           reduce using rule 7 (statement -> if_statement .)
    LBRACKET        reduce using rule 7 (statement -> if_statement .)
    LPAREN          reduce using rule 7 (statement -> if_statement .)
    MINUS           reduce using rule 7 (statement -> if_statement .)
    PLUS            reduce using rule 7 (statement -> if_statement .)
    NOT             reduce using rule 7 (statement -> if_statement .)
    INT_LITERAL     reduce using rule 7 (statement -> if_statement .)
    FLOAT_LITERAL   reduce using rule 7 (statement -> if_statement .)
    STRING          reduce using rule 7 (statement -> if_statement .)
    TRUE            reduce using rule 7 (statement -> if_statement .)
    FALSE           reduce using rule 7 (statement -> if_statement .)
    NIL             reduce using rule 7 (statement -> if_statement .)
    $end            reduce using rule 7 (statement -> if_statement .)
    RBRACE          reduce using rule 7 (statement -> if_statement .)
    DEFAULT         reduce using rule 7 (statement -> if_statement .)
    CASE            reduce using rule 7 (statement -> if_statement .)


state 8

    (8) statement -> guard_statement .

    NEWLINE         reduce using rule 8 (statement -> guard_statement .)
    LET             reduce using rule 8 (statement -> guard_statement .)
    VAR             reduce using rule 8 (statement -> guard_statement .)
    IF              reduce using rule 8 (statement -> guard_statement .)
    GUARD           reduce using rule 8 (statement -> guard_statement .)
    SWITCH          reduce using rule 8 (statement -> guard_statement .)
    IDENTIFIER      reduce using rule 8 (statement -> guard_statement .)
    RETURN          reduce using rule 8 (statement -> guard_statement .)
    BREAK           reduce using rule 8 (statement -> guard_statement .)
    CONTINUE        reduce using rule 8 (statement -> guard_statement .)
    SELF            reduce using rule 8 (statement -> guard_statement .)
    FOR             reduce using rule 8 (statement -> guard_statement .)
    WHILE           reduce using rule 8 (statement -> guard_statement .)
    FUNC            reduce using rule 8 (statement -> guard_statement .)
    CLASS           reduce using rule 8 (statement -> guard_statement .)
    LBRACKET        reduce using rule 8 (statement -> guard_statement .)
    LPAREN          reduce using rule 8 (statement -> guard_statement .)
    MINUS           reduce using rule 8 (statement -> guard_statement .)
    PLUS            reduce using rule 8 (statement -> guard_statement .)
    NOT             reduce using rule 8 (statement -> guard_statement .)
    INT_LITERAL     reduce using rule 8 (statement -> guard_statement .)
    FLOAT_LITERAL   reduce using rule 8 (statement -> guard_statement .)
    STRING          reduce using rule 8 (statement -> guard_statement .)
    TRUE            reduce using rule 8 (statement -> guard_statement .)
    FALSE           reduce using rule 8 (statement -> guard_statement .)
    NIL             reduce using rule 8 (statement -> guard_statement .)
    $end            reduce using rule 8 (statement -> guard_statement .)
    RBRACE          reduce using rule 8 (statement -> guard_statement .)
    DEFAULT         reduce using rule 8 (statement -> guard_statement .)
    CASE            reduce using rule 8 (statement -> guard_statement .)


state 9

    (9) statement -> while_statement .

    NEWLINE         reduce using rule 9 (statement -> while_statement .)
    LET             reduce using rule 9 (statement -> while_statement .)
    VAR             reduce using rule 9 (statement -> while_statement .)
    IF              reduce using rule 9 (statement -> while_statement .)
    GUARD           reduce using rule 9 (statement -> while_statement .)
    SWITCH          reduce using rule 9 (statement -> while_statement .)
    IDENTIFIER      reduce using rule 9 (statement -> while_statement .)
    RETURN          reduce using rule 9 (statement -> while_statement .)
    BREAK           reduce using rule 9 (statement -> while_statement .)
    CONTINUE        reduce using rule 9 (statement -> while_statement .)
    SELF            reduce using rule 9 (statement -> while_statement .)
    FOR             reduce using rule 9 (statement -> while_statement .)
    WHILE           reduce using rule 9 (statement -> while_statement .)
    FUNC            reduce using rule 9 (statement -> while_statement .)
    CLASS           reduce using rule 9 (statement -> while_statement .)
    LBRACKET        reduce using rule 9 (statement -> while_statement .)
    LPAREN          reduce using rule 9 (statement -> while_statement .)
    MINUS           reduce using rule 9 (statement -> while_statement .)
    PLUS            reduce using rule 9 (statement -> while_statement .)
    NOT             reduce using rule 9 (statement -> while_statement .)
    INT_LITERAL     reduce using rule 9 (statement -> while_statement .)
    FLOAT_LITERAL   reduce using rule 9 (statement -> while_statement .)
    STRING          reduce using rule 9 (statement -> while_statement .)
    TRUE            reduce using rule 9 (statement -> while_statement .)
    FALSE           reduce using rule 9 (statement -> while_statement .)
    NIL             reduce using rule 9 (statement -> while_statement .)
    $end            reduce using rule 9 (statement -> while_statement .)
    RBRACE          reduce using rule 9 (statement -> while_statement .)
    DEFAULT         reduce using rule 9 (statement -> while_statement .)
    CASE            reduce using rule 9 (statement -> while_statement .)


state 10

    (10) statement -> switch_statement .

    NEWLINE         reduce using rule 10 (statement -> switch_statement .)
    LET             reduce using rule 10 (statement -> switch_statement .)
    VAR             reduce using rule 10 (statement -> switch_statement .)
    IF              reduce using rule 10 (statement -> switch_statement .)
    GUARD           reduce using rule 10 (statement -> switch_statement .)
    SWITCH          reduce using rule 10 (statement -> switch_statement .)
    IDENTIFIER      reduce using rule 10 (statement -> switch_statement .)
    RETURN          reduce using rule 10 (statement -> switch_statement .)
    BREAK           reduce using rule 10 (statement -> switch_statement .)
    CONTINUE        reduce using rule 10 (statement -> switch_statement .)
    SELF            reduce using rule 10 (statement -> switch_statement .)
    FOR             reduce using rule 10 (statement -> switch_statement .)
    WHILE           reduce using rule 10 (statement -> switch_statement .)
    FUNC            reduce using rule 10 (statement -> switch_statement .)
    CLASS           reduce using rule 10 (statement -> switch_statement .)
    LBRACKET        reduce using rule 10 (statement -> switch_statement .)
    LPAREN          reduce using rule 10 (statement -> switch_statement .)
    MINUS           reduce using rule 10 (statement -> switch_statement .)
    PLUS            reduce using rule 10 (statement -> switch_statement .)
    NOT             reduce using rule 10 (statement -> switch_statement .)
    INT_LITERAL     reduce using rule 10 (statement -> switch_statement .)
    FLOAT_LITERAL   reduce using rule 10 (statement -> switch_statement .)
    STRING          reduce using rule 10 (statement -> switch_statement .)
    TRUE            reduce using rule 10 (statement -> switch_statement .)
    FALSE           reduce using rule 10 (statement -> switch_statement .)
    NIL             reduce using rule 10 (statement -> switch_statement .)
    $end            reduce using rule 10 (statement -> switch_statement .)
    RBRACE          reduce using rule 10 (statement -> switch_statement .)
    DEFAULT         reduce using rule 10 (statement -> switch_statement .)
    CASE            reduce using rule 10 (statement -> switch_statement .)


state 11

    (11) statement -> function_declaration .

    NEWLINE         reduce using rule 11 (statement -> function_declaration .)
    LET             reduce using rule 11 (statement -> function_declaration .)
    VAR             reduce using rule 11 (statement -> function_declaration .)
    IF              reduce using rule 11 (statement -> function_declaration .)
    GUARD           reduce using rule 11 (statement -> function_declaration .)
    SWITCH          reduce using rule 11 (statement -> function_declaration .)
    IDENTIFIER      reduce using rule 11 (statement -> function_declaration .)
    RETURN          reduce using rule 11 (statement -> function_declaration .)
    BREAK           reduce using rule 11 (statement -> function_declaration .)
    CONTINUE        reduce using rule 11 (statement -> function_declaration .)
    SELF            reduce using rule 11 (statement -> function_declaration .)
    FOR             reduce using rule 11 (statement -> function_declaration .)
    WHILE           reduce using rule 11 (statement -> function_declaration .)
    FUNC            reduce using rule 11 (statement -> function_declaration .)
    CLASS           reduce using rule 11 (statement -> function_declaration .)
    LBRACKET        reduce using rule 11 (statement -> function_declaration .)
    LPAREN          reduce using rule 11 (statement -> function_declaration .)
    MINUS           reduce using rule 11 (statement -> function_declaration .)
    PLUS            reduce using rule 11 (statement -> function_declaration .)
    NOT             reduce using rule 11 (statement -> function_declaration .)
    INT_LITERAL     reduce using rule 11 (statement -> function_declaration .)
    FLOAT_LITERAL   reduce using rule 11 (statement -> function_declaration .)
    STRING          reduce using rule 11 (statement -> function_declaration .)
    TRUE            reduce using rule 11 (statement -> function_declaration .)
    FALSE           reduce using rule 11 (statement -> function_declaration .)
    NIL             reduce using rule 11 (statement -> function_declaration .)
    $end            reduce using rule 11 (statement -> function_declaration .)
    RBRACE          reduce using rule 11 (statement -> function_declaration .)
    DEFAULT         reduce using rule 11 (statement -> function_declaration .)
    CASE            reduce using rule 11 (statement -> function_declaration .)


state 12

    (12) statement -> function_call_statement .

    NEWLINE         reduce using rule 12 (statement -> function_call_statement .)
    LET             reduce using rule 12 (statement -> function_call_statement .)
    VAR             reduce using rule 12 (statement -> function_call_statement .)
    IF              reduce using rule 12 (statement -> function_call_statement .)
    GUARD           reduce using rule 12 (statement -> function_call_statement .)
    SWITCH          reduce using rule 12 (statement -> function_call_statement .)
    IDENTIFIER      reduce using rule 12 (statement -> function_call_statement .)
    RETURN          reduce using rule 12 (statement -> function_call_statement .)
    BREAK           reduce using rule 12 (statement -> function_call_statement .)
    CONTINUE        reduce using rule 12 (statement -> function_call_statement .)
    SELF            reduce using rule 12 (statement -> function_call_statement .)
    FOR             reduce using rule 12 (statement -> function_call_statement .)
    WHILE           reduce using rule 12 (statement -> function_call_statement .)
    FUNC            reduce using rule 12 (statement -> function_call_statement .)
    CLASS           reduce using rule 12 (statement -> function_call_statement .)
    LBRACKET        reduce using rule 12 (statement -> function_call_statement .)
    LPAREN          reduce using rule 12 (statement -> function_call_statement .)
    MINUS           reduce using rule 12 (statement -> function_call_statement .)
    PLUS            reduce using rule 12 (statement -> function_call_statement .)
    NOT             reduce using rule 12 (statement -> function_call_statement .)
    INT_LITERAL     reduce using rule 12 (statement -> function_call_statement .)
    FLOAT_LITERAL   reduce using rule 12 (statement -> function_call_statement .)
    STRING          reduce using rule 12 (statement -> function_call_statement .)
    TRUE            reduce using rule 12 (statement -> function_call_statement .)
    FALSE           reduce using rule 12 (statement -> function_call_statement .)
    NIL             reduce using rule 12 (statement -> function_call_statement .)
    $end            reduce using rule 12 (statement -> function_call_statement .)
    RBRACE          reduce using rule 12 (statement -> function_call_statement .)
    DEFAULT         reduce using rule 12 (statement -> function_call_statement .)
    CASE            reduce using rule 12 (statement -> function_call_statement .)


state 13

    (13) statement -> class_declaration .

    NEWLINE         reduce using rule 13 (statement -> class_declaration .)
    LET             reduce using rule 13 (statement -> class_declaration .)
    VAR             reduce using rule 13 (statement -> class_declaration .)
    IF              reduce using rule 13 (statement -> class_declaration .)
    GUARD           reduce using rule 13 (statement -> class_declaration .)
    SWITCH          reduce using rule 13 (statement -> class_declaration .)
    IDENTIFIER      reduce using rule 13 (statement -> class_declaration .)
    RETURN          reduce using rule 13 (statement -> class_declaration .)
    BREAK           reduce using rule 13 (statement -> class_declaration .)
    CONTINUE        reduce using rule 13 (statement -> class_declaration .)
    SELF            reduce using rule 13 (statement -> class_declaration .)
    FOR             reduce using rule 13 (statement -> class_declaration .)
    WHILE           reduce using rule 13 (statement -> class_declaration .)
    FUNC            reduce using rule 13 (statement -> class_declaration .)
    CLASS           reduce using rule 13 (statement -> class_declaration .)
    LBRACKET        reduce using rule 13 (statement -> class_declaration .)
    LPAREN          reduce using rule 13 (statement -> class_declaration .)
    MINUS           reduce using rule 13 (statement -> class_declaration .)
    PLUS            reduce using rule 13 (statement -> class_declaration .)
    NOT             reduce using rule 13 (statement -> class_declaration .)
    INT_LITERAL     reduce using rule 13 (statement -> class_declaration .)
    FLOAT_LITERAL   reduce using rule 13 (statement -> class_declaration .)
    STRING          reduce using rule 13 (statement -> class_declaration .)
    TRUE            reduce using rule 13 (statement -> class_declaration .)
    FALSE           reduce using rule 13 (statement -> class_declaration .)
    NIL             reduce using rule 13 (statement -> class_declaration .)
    $end            reduce using rule 13 (statement -> class_declaration .)
    RBRACE          reduce using rule 13 (statement -> class_declaration .)
    DEFAULT         reduce using rule 13 (statement -> class_declaration .)
    CASE            reduce using rule 13 (statement -> class_declaration .)


state 14

    (14) statement -> expression_statement .

    NEWLINE         reduce using rule 14 (statement -> expression_statement .)
    LET             reduce using rule 14 (statement -> expression_statement .)
    VAR             reduce using rule 14 (statement -> expression_statement .)
    IF              reduce using rule 14 (statement -> expression_statement .)
    GUARD           reduce using rule 14 (statement -> expression_statement .)
    SWITCH          reduce using rule 14 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 14 (statement -> expression_statement .)
    RETURN          reduce using rule 14 (statement -> expression_statement .)
    BREAK           reduce using rule 14 (statement -> expression_statement .)
    CONTINUE        reduce using rule 14 (statement -> expression_statement .)
    SELF            reduce using rule 14 (statement -> expression_statement .)
    FOR             reduce using rule 14 (statement -> expression_statement .)
    WHILE           reduce using rule 14 (statement -> expression_statement .)
    FUNC            reduce using rule 14 (statement -> expression_statement .)
    CLASS           reduce using rule 14 (statement -> expression_statement .)
    LBRACKET        reduce using rule 14 (statement -> expression_statement .)
    LPAREN          reduce using rule 14 (statement -> expression_statement .)
    MINUS           reduce using rule 14 (statement -> expression_statement .)
    PLUS            reduce using rule 14 (statement -> expression_statement .)
    NOT             reduce using rule 14 (statement -> expression_statement .)
    INT_LITERAL     reduce using rule 14 (statement -> expression_statement .)
    FLOAT_LITERAL   reduce using rule 14 (statement -> expression_statement .)
    STRING          reduce using rule 14 (statement -> expression_statement .)
    TRUE            reduce using rule 14 (statement -> expression_statement .)
    FALSE           reduce using rule 14 (statement -> expression_statement .)
    NIL             reduce using rule 14 (statement -> expression_statement .)
    $end            reduce using rule 14 (statement -> expression_statement .)
    RBRACE          reduce using rule 14 (statement -> expression_statement .)
    DEFAULT         reduce using rule 14 (statement -> expression_statement .)
    CASE            reduce using rule 14 (statement -> expression_statement .)


state 15

    (15) statement -> return_statement .

    NEWLINE         reduce using rule 15 (statement -> return_statement .)
    LET             reduce using rule 15 (statement -> return_statement .)
    VAR             reduce using rule 15 (statement -> return_statement .)
    IF              reduce using rule 15 (statement -> return_statement .)
    GUARD           reduce using rule 15 (statement -> return_statement .)
    SWITCH          reduce using rule 15 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 15 (statement -> return_statement .)
    RETURN          reduce using rule 15 (statement -> return_statement .)
    BREAK           reduce using rule 15 (statement -> return_statement .)
    CONTINUE        reduce using rule 15 (statement -> return_statement .)
    SELF            reduce using rule 15 (statement -> return_statement .)
    FOR             reduce using rule 15 (statement -> return_statement .)
    WHILE           reduce using rule 15 (statement -> return_statement .)
    FUNC            reduce using rule 15 (statement -> return_statement .)
    CLASS           reduce using rule 15 (statement -> return_statement .)
    LBRACKET        reduce using rule 15 (statement -> return_statement .)
    LPAREN          reduce using rule 15 (statement -> return_statement .)
    MINUS           reduce using rule 15 (statement -> return_statement .)
    PLUS            reduce using rule 15 (statement -> return_statement .)
    NOT             reduce using rule 15 (statement -> return_statement .)
    INT_LITERAL     reduce using rule 15 (statement -> return_statement .)
    FLOAT_LITERAL   reduce using rule 15 (statement -> return_statement .)
    STRING          reduce using rule 15 (statement -> return_statement .)
    TRUE            reduce using rule 15 (statement -> return_statement .)
    FALSE           reduce using rule 15 (statement -> return_statement .)
    NIL             reduce using rule 15 (statement -> return_statement .)
    $end            reduce using rule 15 (statement -> return_statement .)
    RBRACE          reduce using rule 15 (statement -> return_statement .)
    DEFAULT         reduce using rule 15 (statement -> return_statement .)
    CASE            reduce using rule 15 (statement -> return_statement .)


state 16

    (16) statement -> break_statement .

    NEWLINE         reduce using rule 16 (statement -> break_statement .)
    LET             reduce using rule 16 (statement -> break_statement .)
    VAR             reduce using rule 16 (statement -> break_statement .)
    IF              reduce using rule 16 (statement -> break_statement .)
    GUARD           reduce using rule 16 (statement -> break_statement .)
    SWITCH          reduce using rule 16 (statement -> break_statement .)
    IDENTIFIER      reduce using rule 16 (statement -> break_statement .)
    RETURN          reduce using rule 16 (statement -> break_statement .)
    BREAK           reduce using rule 16 (statement -> break_statement .)
    CONTINUE        reduce using rule 16 (statement -> break_statement .)
    SELF            reduce using rule 16 (statement -> break_statement .)
    FOR             reduce using rule 16 (statement -> break_statement .)
    WHILE           reduce using rule 16 (statement -> break_statement .)
    FUNC            reduce using rule 16 (statement -> break_statement .)
    CLASS           reduce using rule 16 (statement -> break_statement .)
    LBRACKET        reduce using rule 16 (statement -> break_statement .)
    LPAREN          reduce using rule 16 (statement -> break_statement .)
    MINUS           reduce using rule 16 (statement -> break_statement .)
    PLUS            reduce using rule 16 (statement -> break_statement .)
    NOT             reduce using rule 16 (statement -> break_statement .)
    INT_LITERAL     reduce using rule 16 (statement -> break_statement .)
    FLOAT_LITERAL   reduce using rule 16 (statement -> break_statement .)
    STRING          reduce using rule 16 (statement -> break_statement .)
    TRUE            reduce using rule 16 (statement -> break_statement .)
    FALSE           reduce using rule 16 (statement -> break_statement .)
    NIL             reduce using rule 16 (statement -> break_statement .)
    $end            reduce using rule 16 (statement -> break_statement .)
    RBRACE          reduce using rule 16 (statement -> break_statement .)
    DEFAULT         reduce using rule 16 (statement -> break_statement .)
    CASE            reduce using rule 16 (statement -> break_statement .)


state 17

    (17) statement -> continue_statement .

    NEWLINE         reduce using rule 17 (statement -> continue_statement .)
    LET             reduce using rule 17 (statement -> continue_statement .)
    VAR             reduce using rule 17 (statement -> continue_statement .)
    IF              reduce using rule 17 (statement -> continue_statement .)
    GUARD           reduce using rule 17 (statement -> continue_statement .)
    SWITCH          reduce using rule 17 (statement -> continue_statement .)
    IDENTIFIER      reduce using rule 17 (statement -> continue_statement .)
    RETURN          reduce using rule 17 (statement -> continue_statement .)
    BREAK           reduce using rule 17 (statement -> continue_statement .)
    CONTINUE        reduce using rule 17 (statement -> continue_statement .)
    SELF            reduce using rule 17 (statement -> continue_statement .)
    FOR             reduce using rule 17 (statement -> continue_statement .)
    WHILE           reduce using rule 17 (statement -> continue_statement .)
    FUNC            reduce using rule 17 (statement -> continue_statement .)
    CLASS           reduce using rule 17 (statement -> continue_statement .)
    LBRACKET        reduce using rule 17 (statement -> continue_statement .)
    LPAREN          reduce using rule 17 (statement -> continue_statement .)
    MINUS           reduce using rule 17 (statement -> continue_statement .)
    PLUS            reduce using rule 17 (statement -> continue_statement .)
    NOT             reduce using rule 17 (statement -> continue_statement .)
    INT_LITERAL     reduce using rule 17 (statement -> continue_statement .)
    FLOAT_LITERAL   reduce using rule 17 (statement -> continue_statement .)
    STRING          reduce using rule 17 (statement -> continue_statement .)
    TRUE            reduce using rule 17 (statement -> continue_statement .)
    FALSE           reduce using rule 17 (statement -> continue_statement .)
    NIL             reduce using rule 17 (statement -> continue_statement .)
    $end            reduce using rule 17 (statement -> continue_statement .)
    RBRACE          reduce using rule 17 (statement -> continue_statement .)
    DEFAULT         reduce using rule 17 (statement -> continue_statement .)
    CASE            reduce using rule 17 (statement -> continue_statement .)


state 18

    (18) statement -> NEWLINE .

    NEWLINE         reduce using rule 18 (statement -> NEWLINE .)
    LET             reduce using rule 18 (statement -> NEWLINE .)
    VAR             reduce using rule 18 (statement -> NEWLINE .)
    IF              reduce using rule 18 (statement -> NEWLINE .)
    GUARD           reduce using rule 18 (statement -> NEWLINE .)
    SWITCH          reduce using rule 18 (statement -> NEWLINE .)
    IDENTIFIER      reduce using rule 18 (statement -> NEWLINE .)
    RETURN          reduce using rule 18 (statement -> NEWLINE .)
    BREAK           reduce using rule 18 (statement -> NEWLINE .)
    CONTINUE        reduce using rule 18 (statement -> NEWLINE .)
    SELF            reduce using rule 18 (statement -> NEWLINE .)
    FOR             reduce using rule 18 (statement -> NEWLINE .)
    WHILE           reduce using rule 18 (statement -> NEWLINE .)
    FUNC            reduce using rule 18 (statement -> NEWLINE .)
    CLASS           reduce using rule 18 (statement -> NEWLINE .)
    LBRACKET        reduce using rule 18 (statement -> NEWLINE .)
    LPAREN          reduce using rule 18 (statement -> NEWLINE .)
    MINUS           reduce using rule 18 (statement -> NEWLINE .)
    PLUS            reduce using rule 18 (statement -> NEWLINE .)
    NOT             reduce using rule 18 (statement -> NEWLINE .)
    INT_LITERAL     reduce using rule 18 (statement -> NEWLINE .)
    FLOAT_LITERAL   reduce using rule 18 (statement -> NEWLINE .)
    STRING          reduce using rule 18 (statement -> NEWLINE .)
    TRUE            reduce using rule 18 (statement -> NEWLINE .)
    FALSE           reduce using rule 18 (statement -> NEWLINE .)
    NIL             reduce using rule 18 (statement -> NEWLINE .)
    $end            reduce using rule 18 (statement -> NEWLINE .)
    RBRACE          reduce using rule 18 (statement -> NEWLINE .)
    DEFAULT         reduce using rule 18 (statement -> NEWLINE .)
    CASE            reduce using rule 18 (statement -> NEWLINE .)


state 19

    (20) variable_declaration -> LET . IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> LET . IDENTIFIER ASSIGN expression
    (24) variable_declaration -> LET . IDENTIFIER COLON type_annotation
    (26) variable_declaration -> LET . IDENTIFIER COLON tuple_type

    IDENTIFIER      shift and go to state 51


state 20

    (143) function_call_statement -> IDENTIFIER . LPAREN argument_list RPAREN
    (144) function_call_statement -> IDENTIFIER . LPAREN RPAREN
    (71) lvalue -> IDENTIFIER .
    (100) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (103) expression -> IDENTIFIER . LPAREN RPAREN

  ! reduce/reduce conflict for LBRACKET resolved using rule 71 (lvalue -> IDENTIFIER .)
  ! reduce/reduce conflict for DOT resolved using rule 71 (lvalue -> IDENTIFIER .)
  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 52
    ASSIGN          reduce using rule 71 (lvalue -> IDENTIFIER .)
    PLUS_ASSIGN     reduce using rule 71 (lvalue -> IDENTIFIER .)
    MINUS_ASSIGN    reduce using rule 71 (lvalue -> IDENTIFIER .)
    TIMES_ASSIGN    reduce using rule 71 (lvalue -> IDENTIFIER .)
    DIV_ASSIGN      reduce using rule 71 (lvalue -> IDENTIFIER .)
    MOD_ASSIGN      reduce using rule 71 (lvalue -> IDENTIFIER .)
    DOT             reduce using rule 71 (lvalue -> IDENTIFIER .)
    LBRACKET        reduce using rule 71 (lvalue -> IDENTIFIER .)
    PLUS            reduce using rule 100 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 100 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 100 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (expression -> IDENTIFIER .)
    MODULO          reduce using rule 100 (expression -> IDENTIFIER .)
    AND             reduce using rule 100 (expression -> IDENTIFIER .)
    OR              reduce using rule 100 (expression -> IDENTIFIER .)
    EQ              reduce using rule 100 (expression -> IDENTIFIER .)
    NE              reduce using rule 100 (expression -> IDENTIFIER .)
    GT              reduce using rule 100 (expression -> IDENTIFIER .)
    LT              reduce using rule 100 (expression -> IDENTIFIER .)
    GE              reduce using rule 100 (expression -> IDENTIFIER .)
    LE              reduce using rule 100 (expression -> IDENTIFIER .)
    QUESTION        reduce using rule 100 (expression -> IDENTIFIER .)
    NIL_COALESCE    reduce using rule 100 (expression -> IDENTIFIER .)
    NEWLINE         reduce using rule 100 (expression -> IDENTIFIER .)
    LET             reduce using rule 100 (expression -> IDENTIFIER .)
    VAR             reduce using rule 100 (expression -> IDENTIFIER .)
    IF              reduce using rule 100 (expression -> IDENTIFIER .)
    GUARD           reduce using rule 100 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 100 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 100 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 100 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 100 (expression -> IDENTIFIER .)
    SELF            reduce using rule 100 (expression -> IDENTIFIER .)
    FOR             reduce using rule 100 (expression -> IDENTIFIER .)
    WHILE           reduce using rule 100 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 100 (expression -> IDENTIFIER .)
    CLASS           reduce using rule 100 (expression -> IDENTIFIER .)
    NOT             reduce using rule 100 (expression -> IDENTIFIER .)
    INT_LITERAL     reduce using rule 100 (expression -> IDENTIFIER .)
    FLOAT_LITERAL   reduce using rule 100 (expression -> IDENTIFIER .)
    STRING          reduce using rule 100 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 100 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 100 (expression -> IDENTIFIER .)
    NIL             reduce using rule 100 (expression -> IDENTIFIER .)
    $end            reduce using rule 100 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 100 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 100 (expression -> IDENTIFIER .)
    CASE            reduce using rule 100 (expression -> IDENTIFIER .)

  ! LBRACKET        [ reduce using rule 100 (expression -> IDENTIFIER .) ]
  ! DOT             [ reduce using rule 100 (expression -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 100 (expression -> IDENTIFIER .) ]


state 21

    (19) expression_statement -> expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 19 (expression_statement -> expression .)
    LET             reduce using rule 19 (expression_statement -> expression .)
    VAR             reduce using rule 19 (expression_statement -> expression .)
    IF              reduce using rule 19 (expression_statement -> expression .)
    GUARD           reduce using rule 19 (expression_statement -> expression .)
    SWITCH          reduce using rule 19 (expression_statement -> expression .)
    IDENTIFIER      reduce using rule 19 (expression_statement -> expression .)
    RETURN          reduce using rule 19 (expression_statement -> expression .)
    BREAK           reduce using rule 19 (expression_statement -> expression .)
    CONTINUE        reduce using rule 19 (expression_statement -> expression .)
    SELF            reduce using rule 19 (expression_statement -> expression .)
    FOR             reduce using rule 19 (expression_statement -> expression .)
    WHILE           reduce using rule 19 (expression_statement -> expression .)
    FUNC            reduce using rule 19 (expression_statement -> expression .)
    CLASS           reduce using rule 19 (expression_statement -> expression .)
    LPAREN          reduce using rule 19 (expression_statement -> expression .)
    NOT             reduce using rule 19 (expression_statement -> expression .)
    INT_LITERAL     reduce using rule 19 (expression_statement -> expression .)
    FLOAT_LITERAL   reduce using rule 19 (expression_statement -> expression .)
    STRING          reduce using rule 19 (expression_statement -> expression .)
    TRUE            reduce using rule 19 (expression_statement -> expression .)
    FALSE           reduce using rule 19 (expression_statement -> expression .)
    NIL             reduce using rule 19 (expression_statement -> expression .)
    $end            reduce using rule 19 (expression_statement -> expression .)
    RBRACE          reduce using rule 19 (expression_statement -> expression .)
    DEFAULT         reduce using rule 19 (expression_statement -> expression .)
    CASE            reduce using rule 19 (expression_statement -> expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 19 (expression_statement -> expression .) ]
  ! MINUS           [ reduce using rule 19 (expression_statement -> expression .) ]
  ! PLUS            [ reduce using rule 19 (expression_statement -> expression .) ]


state 22

    (21) variable_declaration -> VAR . IDENTIFIER COLON type_annotation ASSIGN expression
    (23) variable_declaration -> VAR . IDENTIFIER ASSIGN expression
    (25) variable_declaration -> VAR . IDENTIFIER COLON type_annotation
    (27) variable_declaration -> VAR . IDENTIFIER COLON tuple_type

    IDENTIFIER      shift and go to state 70


state 23

    (65) assignment -> lvalue . ASSIGN expression
    (66) assignment -> lvalue . PLUS_ASSIGN expression
    (67) assignment -> lvalue . MINUS_ASSIGN expression
    (68) assignment -> lvalue . TIMES_ASSIGN expression
    (69) assignment -> lvalue . DIV_ASSIGN expression
    (70) assignment -> lvalue . MOD_ASSIGN expression
    (73) lvalue -> lvalue . DOT IDENTIFIER
    (74) lvalue -> lvalue . LBRACKET expression RBRACKET

    ASSIGN          shift and go to state 71
    PLUS_ASSIGN     shift and go to state 72
    MINUS_ASSIGN    shift and go to state 73
    TIMES_ASSIGN    shift and go to state 74
    DIV_ASSIGN      shift and go to state 75
    MOD_ASSIGN      shift and go to state 76
    DOT             shift and go to state 77
    LBRACKET        shift and go to state 78


state 24

    (104) for_statement -> for_header . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 79


state 25

    (109) if_statement -> IF . expression LBRACE statement_list RBRACE
    (110) if_statement -> IF . expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> IF . expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> IF . expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 80

state 26

    (116) guard_statement -> GUARD . expression ELSE LBRACE statement_list RBRACE
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 83

state 27

    (117) while_statement -> while_header . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 84


state 28

    (121) switch_statement -> SWITCH . expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> SWITCH . expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 85

state 29

    (132) function_declaration -> func_header . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 86


state 30

    (58) expression -> LPAREN . tuple_elements RPAREN
    (93) expression -> LPAREN . expression RPAREN
    (59) tuple_elements -> . tuple_elements COMMA tuple_element
    (60) tuple_elements -> . tuple_element
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN
    (61) tuple_element -> . IDENTIFIER COLON expression
    (62) tuple_element -> . expression

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 90
    SELF            shift and go to state 82

    tuple_elements                 shift and go to state 87
    expression                     shift and go to state 88
    tuple_element                  shift and go to state 89

state 31

    (147) class_declaration -> class_header . LBRACE class_body RBRACE

    LBRACE          shift and go to state 91


state 32

    (141) return_statement -> RETURN . expression
    (142) return_statement -> RETURN .
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for INT_LITERAL resolved as shift
  ! shift/reduce conflict for FLOAT_LITERAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for SELF resolved as shift
    NEWLINE         reduce using rule 142 (return_statement -> RETURN .)
    LET             reduce using rule 142 (return_statement -> RETURN .)
    VAR             reduce using rule 142 (return_statement -> RETURN .)
    IF              reduce using rule 142 (return_statement -> RETURN .)
    GUARD           reduce using rule 142 (return_statement -> RETURN .)
    SWITCH          reduce using rule 142 (return_statement -> RETURN .)
    RETURN          reduce using rule 142 (return_statement -> RETURN .)
    BREAK           reduce using rule 142 (return_statement -> RETURN .)
    CONTINUE        reduce using rule 142 (return_statement -> RETURN .)
    FOR             reduce using rule 142 (return_statement -> RETURN .)
    WHILE           reduce using rule 142 (return_statement -> RETURN .)
    FUNC            reduce using rule 142 (return_statement -> RETURN .)
    CLASS           reduce using rule 142 (return_statement -> RETURN .)
    $end            reduce using rule 142 (return_statement -> RETURN .)
    RBRACE          reduce using rule 142 (return_statement -> RETURN .)
    DEFAULT         reduce using rule 142 (return_statement -> RETURN .)
    CASE            reduce using rule 142 (return_statement -> RETURN .)
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

  ! IDENTIFIER      [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! SELF            [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! LPAREN          [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! MINUS           [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! PLUS            [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! NOT             [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! INT_LITERAL     [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! FLOAT_LITERAL   [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! STRING          [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! TRUE            [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! FALSE           [ reduce using rule 142 (return_statement -> RETURN .) ]
  ! NIL             [ reduce using rule 142 (return_statement -> RETURN .) ]

    expression                     shift and go to state 92

state 33

    (119) break_statement -> BREAK .

    NEWLINE         reduce using rule 119 (break_statement -> BREAK .)
    LET             reduce using rule 119 (break_statement -> BREAK .)
    VAR             reduce using rule 119 (break_statement -> BREAK .)
    IF              reduce using rule 119 (break_statement -> BREAK .)
    GUARD           reduce using rule 119 (break_statement -> BREAK .)
    SWITCH          reduce using rule 119 (break_statement -> BREAK .)
    IDENTIFIER      reduce using rule 119 (break_statement -> BREAK .)
    RETURN          reduce using rule 119 (break_statement -> BREAK .)
    BREAK           reduce using rule 119 (break_statement -> BREAK .)
    CONTINUE        reduce using rule 119 (break_statement -> BREAK .)
    SELF            reduce using rule 119 (break_statement -> BREAK .)
    FOR             reduce using rule 119 (break_statement -> BREAK .)
    WHILE           reduce using rule 119 (break_statement -> BREAK .)
    FUNC            reduce using rule 119 (break_statement -> BREAK .)
    CLASS           reduce using rule 119 (break_statement -> BREAK .)
    LBRACKET        reduce using rule 119 (break_statement -> BREAK .)
    LPAREN          reduce using rule 119 (break_statement -> BREAK .)
    MINUS           reduce using rule 119 (break_statement -> BREAK .)
    PLUS            reduce using rule 119 (break_statement -> BREAK .)
    NOT             reduce using rule 119 (break_statement -> BREAK .)
    INT_LITERAL     reduce using rule 119 (break_statement -> BREAK .)
    FLOAT_LITERAL   reduce using rule 119 (break_statement -> BREAK .)
    STRING          reduce using rule 119 (break_statement -> BREAK .)
    TRUE            reduce using rule 119 (break_statement -> BREAK .)
    FALSE           reduce using rule 119 (break_statement -> BREAK .)
    NIL             reduce using rule 119 (break_statement -> BREAK .)
    $end            reduce using rule 119 (break_statement -> BREAK .)
    RBRACE          reduce using rule 119 (break_statement -> BREAK .)
    DEFAULT         reduce using rule 119 (break_statement -> BREAK .)
    CASE            reduce using rule 119 (break_statement -> BREAK .)


state 34

    (120) continue_statement -> CONTINUE .

    NEWLINE         reduce using rule 120 (continue_statement -> CONTINUE .)
    LET             reduce using rule 120 (continue_statement -> CONTINUE .)
    VAR             reduce using rule 120 (continue_statement -> CONTINUE .)
    IF              reduce using rule 120 (continue_statement -> CONTINUE .)
    GUARD           reduce using rule 120 (continue_statement -> CONTINUE .)
    SWITCH          reduce using rule 120 (continue_statement -> CONTINUE .)
    IDENTIFIER      reduce using rule 120 (continue_statement -> CONTINUE .)
    RETURN          reduce using rule 120 (continue_statement -> CONTINUE .)
    BREAK           reduce using rule 120 (continue_statement -> CONTINUE .)
    CONTINUE        reduce using rule 120 (continue_statement -> CONTINUE .)
    SELF            reduce using rule 120 (continue_statement -> CONTINUE .)
    FOR             reduce using rule 120 (continue_statement -> CONTINUE .)
    WHILE           reduce using rule 120 (continue_statement -> CONTINUE .)
    FUNC            reduce using rule 120 (continue_statement -> CONTINUE .)
    CLASS           reduce using rule 120 (continue_statement -> CONTINUE .)
    LBRACKET        reduce using rule 120 (continue_statement -> CONTINUE .)
    LPAREN          reduce using rule 120 (continue_statement -> CONTINUE .)
    MINUS           reduce using rule 120 (continue_statement -> CONTINUE .)
    PLUS            reduce using rule 120 (continue_statement -> CONTINUE .)
    NOT             reduce using rule 120 (continue_statement -> CONTINUE .)
    INT_LITERAL     reduce using rule 120 (continue_statement -> CONTINUE .)
    FLOAT_LITERAL   reduce using rule 120 (continue_statement -> CONTINUE .)
    STRING          reduce using rule 120 (continue_statement -> CONTINUE .)
    TRUE            reduce using rule 120 (continue_statement -> CONTINUE .)
    FALSE           reduce using rule 120 (continue_statement -> CONTINUE .)
    NIL             reduce using rule 120 (continue_statement -> CONTINUE .)
    $end            reduce using rule 120 (continue_statement -> CONTINUE .)
    RBRACE          reduce using rule 120 (continue_statement -> CONTINUE .)
    DEFAULT         reduce using rule 120 (continue_statement -> CONTINUE .)
    CASE            reduce using rule 120 (continue_statement -> CONTINUE .)


state 35

    (72) lvalue -> SELF . DOT IDENTIFIER
    (101) expression -> SELF . DOT IDENTIFIER

    DOT             shift and go to state 93


state 36

    (42) expression -> LBRACKET . array_elements RBRACKET
    (43) expression -> LBRACKET . RBRACKET
    (48) expression -> LBRACKET . dictionary_pairs RBRACKET
    (49) expression -> LBRACKET . COLON RBRACKET
    (44) array_elements -> . array_elements COMMA expression
    (45) array_elements -> . expression
    (50) dictionary_pairs -> . dictionary_pairs COMMA dictionary_pair
    (51) dictionary_pairs -> . dictionary_pair
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN
    (52) dictionary_pair -> . expression COLON expression

    RBRACKET        shift and go to state 95
    COLON           shift and go to state 97
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    array_elements                 shift and go to state 94
    dictionary_pairs               shift and go to state 96
    expression                     shift and go to state 98
    dictionary_pair                shift and go to state 99

state 37

    (105) for_header -> FOR . IDENTIFIER IN range_expression
    (106) for_header -> FOR . IDENTIFIER IN expression

    IDENTIFIER      shift and go to state 100


state 38

    (118) while_header -> WHILE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 101

state 39

    (133) func_header -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> FUNC . IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> FUNC . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 102


state 40

    (148) class_header -> CLASS . IDENTIFIER

    IDENTIFIER      shift and go to state 103


state 41

    (94) expression -> INT_LITERAL .

    LBRACKET        reduce using rule 94 (expression -> INT_LITERAL .)
    DOT             reduce using rule 94 (expression -> INT_LITERAL .)
    PLUS            reduce using rule 94 (expression -> INT_LITERAL .)
    MINUS           reduce using rule 94 (expression -> INT_LITERAL .)
    TIMES           reduce using rule 94 (expression -> INT_LITERAL .)
    DIVIDE          reduce using rule 94 (expression -> INT_LITERAL .)
    MODULO          reduce using rule 94 (expression -> INT_LITERAL .)
    AND             reduce using rule 94 (expression -> INT_LITERAL .)
    OR              reduce using rule 94 (expression -> INT_LITERAL .)
    EQ              reduce using rule 94 (expression -> INT_LITERAL .)
    NE              reduce using rule 94 (expression -> INT_LITERAL .)
    GT              reduce using rule 94 (expression -> INT_LITERAL .)
    LT              reduce using rule 94 (expression -> INT_LITERAL .)
    GE              reduce using rule 94 (expression -> INT_LITERAL .)
    LE              reduce using rule 94 (expression -> INT_LITERAL .)
    QUESTION        reduce using rule 94 (expression -> INT_LITERAL .)
    NIL_COALESCE    reduce using rule 94 (expression -> INT_LITERAL .)
    NEWLINE         reduce using rule 94 (expression -> INT_LITERAL .)
    LET             reduce using rule 94 (expression -> INT_LITERAL .)
    VAR             reduce using rule 94 (expression -> INT_LITERAL .)
    IF              reduce using rule 94 (expression -> INT_LITERAL .)
    GUARD           reduce using rule 94 (expression -> INT_LITERAL .)
    SWITCH          reduce using rule 94 (expression -> INT_LITERAL .)
    IDENTIFIER      reduce using rule 94 (expression -> INT_LITERAL .)
    RETURN          reduce using rule 94 (expression -> INT_LITERAL .)
    BREAK           reduce using rule 94 (expression -> INT_LITERAL .)
    CONTINUE        reduce using rule 94 (expression -> INT_LITERAL .)
    SELF            reduce using rule 94 (expression -> INT_LITERAL .)
    FOR             reduce using rule 94 (expression -> INT_LITERAL .)
    WHILE           reduce using rule 94 (expression -> INT_LITERAL .)
    FUNC            reduce using rule 94 (expression -> INT_LITERAL .)
    CLASS           reduce using rule 94 (expression -> INT_LITERAL .)
    LPAREN          reduce using rule 94 (expression -> INT_LITERAL .)
    NOT             reduce using rule 94 (expression -> INT_LITERAL .)
    INT_LITERAL     reduce using rule 94 (expression -> INT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 94 (expression -> INT_LITERAL .)
    STRING          reduce using rule 94 (expression -> INT_LITERAL .)
    TRUE            reduce using rule 94 (expression -> INT_LITERAL .)
    FALSE           reduce using rule 94 (expression -> INT_LITERAL .)
    NIL             reduce using rule 94 (expression -> INT_LITERAL .)
    $end            reduce using rule 94 (expression -> INT_LITERAL .)
    LBRACE          reduce using rule 94 (expression -> INT_LITERAL .)
    ELSE            reduce using rule 94 (expression -> INT_LITERAL .)
    RPAREN          reduce using rule 94 (expression -> INT_LITERAL .)
    COMMA           reduce using rule 94 (expression -> INT_LITERAL .)
    RBRACE          reduce using rule 94 (expression -> INT_LITERAL .)
    DEFAULT         reduce using rule 94 (expression -> INT_LITERAL .)
    CASE            reduce using rule 94 (expression -> INT_LITERAL .)
    COLON           reduce using rule 94 (expression -> INT_LITERAL .)
    RBRACKET        reduce using rule 94 (expression -> INT_LITERAL .)
    CLOSED_RANGE    reduce using rule 94 (expression -> INT_LITERAL .)
    HALF_OPEN_RANGE reduce using rule 94 (expression -> INT_LITERAL .)


state 42

    (81) expression -> PLUS . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 104

state 43

    (80) expression -> MINUS . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 105

state 44

    (84) expression -> NOT . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 106

state 45

    (95) expression -> FLOAT_LITERAL .

    LBRACKET        reduce using rule 95 (expression -> FLOAT_LITERAL .)
    DOT             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    PLUS            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    MINUS           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    TIMES           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    MODULO          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    AND             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    OR              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    EQ              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    NE              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    GT              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    LT              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    GE              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    LE              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    QUESTION        reduce using rule 95 (expression -> FLOAT_LITERAL .)
    NIL_COALESCE    reduce using rule 95 (expression -> FLOAT_LITERAL .)
    NEWLINE         reduce using rule 95 (expression -> FLOAT_LITERAL .)
    LET             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    VAR             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    IF              reduce using rule 95 (expression -> FLOAT_LITERAL .)
    GUARD           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    SWITCH          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    IDENTIFIER      reduce using rule 95 (expression -> FLOAT_LITERAL .)
    RETURN          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    BREAK           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    CONTINUE        reduce using rule 95 (expression -> FLOAT_LITERAL .)
    SELF            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    FOR             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    WHILE           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    FUNC            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    CLASS           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    LPAREN          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    NOT             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    INT_LITERAL     reduce using rule 95 (expression -> FLOAT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 95 (expression -> FLOAT_LITERAL .)
    STRING          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    TRUE            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    FALSE           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    NIL             reduce using rule 95 (expression -> FLOAT_LITERAL .)
    $end            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    LBRACE          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    ELSE            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    COMMA           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    RBRACE          reduce using rule 95 (expression -> FLOAT_LITERAL .)
    DEFAULT         reduce using rule 95 (expression -> FLOAT_LITERAL .)
    CASE            reduce using rule 95 (expression -> FLOAT_LITERAL .)
    COLON           reduce using rule 95 (expression -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 95 (expression -> FLOAT_LITERAL .)
    CLOSED_RANGE    reduce using rule 95 (expression -> FLOAT_LITERAL .)
    HALF_OPEN_RANGE reduce using rule 95 (expression -> FLOAT_LITERAL .)


state 46

    (96) expression -> STRING .

    LBRACKET        reduce using rule 96 (expression -> STRING .)
    DOT             reduce using rule 96 (expression -> STRING .)
    PLUS            reduce using rule 96 (expression -> STRING .)
    MINUS           reduce using rule 96 (expression -> STRING .)
    TIMES           reduce using rule 96 (expression -> STRING .)
    DIVIDE          reduce using rule 96 (expression -> STRING .)
    MODULO          reduce using rule 96 (expression -> STRING .)
    AND             reduce using rule 96 (expression -> STRING .)
    OR              reduce using rule 96 (expression -> STRING .)
    EQ              reduce using rule 96 (expression -> STRING .)
    NE              reduce using rule 96 (expression -> STRING .)
    GT              reduce using rule 96 (expression -> STRING .)
    LT              reduce using rule 96 (expression -> STRING .)
    GE              reduce using rule 96 (expression -> STRING .)
    LE              reduce using rule 96 (expression -> STRING .)
    QUESTION        reduce using rule 96 (expression -> STRING .)
    NIL_COALESCE    reduce using rule 96 (expression -> STRING .)
    NEWLINE         reduce using rule 96 (expression -> STRING .)
    LET             reduce using rule 96 (expression -> STRING .)
    VAR             reduce using rule 96 (expression -> STRING .)
    IF              reduce using rule 96 (expression -> STRING .)
    GUARD           reduce using rule 96 (expression -> STRING .)
    SWITCH          reduce using rule 96 (expression -> STRING .)
    IDENTIFIER      reduce using rule 96 (expression -> STRING .)
    RETURN          reduce using rule 96 (expression -> STRING .)
    BREAK           reduce using rule 96 (expression -> STRING .)
    CONTINUE        reduce using rule 96 (expression -> STRING .)
    SELF            reduce using rule 96 (expression -> STRING .)
    FOR             reduce using rule 96 (expression -> STRING .)
    WHILE           reduce using rule 96 (expression -> STRING .)
    FUNC            reduce using rule 96 (expression -> STRING .)
    CLASS           reduce using rule 96 (expression -> STRING .)
    LPAREN          reduce using rule 96 (expression -> STRING .)
    NOT             reduce using rule 96 (expression -> STRING .)
    INT_LITERAL     reduce using rule 96 (expression -> STRING .)
    FLOAT_LITERAL   reduce using rule 96 (expression -> STRING .)
    STRING          reduce using rule 96 (expression -> STRING .)
    TRUE            reduce using rule 96 (expression -> STRING .)
    FALSE           reduce using rule 96 (expression -> STRING .)
    NIL             reduce using rule 96 (expression -> STRING .)
    $end            reduce using rule 96 (expression -> STRING .)
    LBRACE          reduce using rule 96 (expression -> STRING .)
    ELSE            reduce using rule 96 (expression -> STRING .)
    RPAREN          reduce using rule 96 (expression -> STRING .)
    COMMA           reduce using rule 96 (expression -> STRING .)
    RBRACE          reduce using rule 96 (expression -> STRING .)
    DEFAULT         reduce using rule 96 (expression -> STRING .)
    CASE            reduce using rule 96 (expression -> STRING .)
    COLON           reduce using rule 96 (expression -> STRING .)
    RBRACKET        reduce using rule 96 (expression -> STRING .)
    CLOSED_RANGE    reduce using rule 96 (expression -> STRING .)
    HALF_OPEN_RANGE reduce using rule 96 (expression -> STRING .)


state 47

    (97) expression -> TRUE .

    LBRACKET        reduce using rule 97 (expression -> TRUE .)
    DOT             reduce using rule 97 (expression -> TRUE .)
    PLUS            reduce using rule 97 (expression -> TRUE .)
    MINUS           reduce using rule 97 (expression -> TRUE .)
    TIMES           reduce using rule 97 (expression -> TRUE .)
    DIVIDE          reduce using rule 97 (expression -> TRUE .)
    MODULO          reduce using rule 97 (expression -> TRUE .)
    AND             reduce using rule 97 (expression -> TRUE .)
    OR              reduce using rule 97 (expression -> TRUE .)
    EQ              reduce using rule 97 (expression -> TRUE .)
    NE              reduce using rule 97 (expression -> TRUE .)
    GT              reduce using rule 97 (expression -> TRUE .)
    LT              reduce using rule 97 (expression -> TRUE .)
    GE              reduce using rule 97 (expression -> TRUE .)
    LE              reduce using rule 97 (expression -> TRUE .)
    QUESTION        reduce using rule 97 (expression -> TRUE .)
    NIL_COALESCE    reduce using rule 97 (expression -> TRUE .)
    NEWLINE         reduce using rule 97 (expression -> TRUE .)
    LET             reduce using rule 97 (expression -> TRUE .)
    VAR             reduce using rule 97 (expression -> TRUE .)
    IF              reduce using rule 97 (expression -> TRUE .)
    GUARD           reduce using rule 97 (expression -> TRUE .)
    SWITCH          reduce using rule 97 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 97 (expression -> TRUE .)
    RETURN          reduce using rule 97 (expression -> TRUE .)
    BREAK           reduce using rule 97 (expression -> TRUE .)
    CONTINUE        reduce using rule 97 (expression -> TRUE .)
    SELF            reduce using rule 97 (expression -> TRUE .)
    FOR             reduce using rule 97 (expression -> TRUE .)
    WHILE           reduce using rule 97 (expression -> TRUE .)
    FUNC            reduce using rule 97 (expression -> TRUE .)
    CLASS           reduce using rule 97 (expression -> TRUE .)
    LPAREN          reduce using rule 97 (expression -> TRUE .)
    NOT             reduce using rule 97 (expression -> TRUE .)
    INT_LITERAL     reduce using rule 97 (expression -> TRUE .)
    FLOAT_LITERAL   reduce using rule 97 (expression -> TRUE .)
    STRING          reduce using rule 97 (expression -> TRUE .)
    TRUE            reduce using rule 97 (expression -> TRUE .)
    FALSE           reduce using rule 97 (expression -> TRUE .)
    NIL             reduce using rule 97 (expression -> TRUE .)
    $end            reduce using rule 97 (expression -> TRUE .)
    LBRACE          reduce using rule 97 (expression -> TRUE .)
    ELSE            reduce using rule 97 (expression -> TRUE .)
    RPAREN          reduce using rule 97 (expression -> TRUE .)
    COMMA           reduce using rule 97 (expression -> TRUE .)
    RBRACE          reduce using rule 97 (expression -> TRUE .)
    DEFAULT         reduce using rule 97 (expression -> TRUE .)
    CASE            reduce using rule 97 (expression -> TRUE .)
    COLON           reduce using rule 97 (expression -> TRUE .)
    RBRACKET        reduce using rule 97 (expression -> TRUE .)
    CLOSED_RANGE    reduce using rule 97 (expression -> TRUE .)
    HALF_OPEN_RANGE reduce using rule 97 (expression -> TRUE .)


state 48

    (98) expression -> FALSE .

    LBRACKET        reduce using rule 98 (expression -> FALSE .)
    DOT             reduce using rule 98 (expression -> FALSE .)
    PLUS            reduce using rule 98 (expression -> FALSE .)
    MINUS           reduce using rule 98 (expression -> FALSE .)
    TIMES           reduce using rule 98 (expression -> FALSE .)
    DIVIDE          reduce using rule 98 (expression -> FALSE .)
    MODULO          reduce using rule 98 (expression -> FALSE .)
    AND             reduce using rule 98 (expression -> FALSE .)
    OR              reduce using rule 98 (expression -> FALSE .)
    EQ              reduce using rule 98 (expression -> FALSE .)
    NE              reduce using rule 98 (expression -> FALSE .)
    GT              reduce using rule 98 (expression -> FALSE .)
    LT              reduce using rule 98 (expression -> FALSE .)
    GE              reduce using rule 98 (expression -> FALSE .)
    LE              reduce using rule 98 (expression -> FALSE .)
    QUESTION        reduce using rule 98 (expression -> FALSE .)
    NIL_COALESCE    reduce using rule 98 (expression -> FALSE .)
    NEWLINE         reduce using rule 98 (expression -> FALSE .)
    LET             reduce using rule 98 (expression -> FALSE .)
    VAR             reduce using rule 98 (expression -> FALSE .)
    IF              reduce using rule 98 (expression -> FALSE .)
    GUARD           reduce using rule 98 (expression -> FALSE .)
    SWITCH          reduce using rule 98 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 98 (expression -> FALSE .)
    RETURN          reduce using rule 98 (expression -> FALSE .)
    BREAK           reduce using rule 98 (expression -> FALSE .)
    CONTINUE        reduce using rule 98 (expression -> FALSE .)
    SELF            reduce using rule 98 (expression -> FALSE .)
    FOR             reduce using rule 98 (expression -> FALSE .)
    WHILE           reduce using rule 98 (expression -> FALSE .)
    FUNC            reduce using rule 98 (expression -> FALSE .)
    CLASS           reduce using rule 98 (expression -> FALSE .)
    LPAREN          reduce using rule 98 (expression -> FALSE .)
    NOT             reduce using rule 98 (expression -> FALSE .)
    INT_LITERAL     reduce using rule 98 (expression -> FALSE .)
    FLOAT_LITERAL   reduce using rule 98 (expression -> FALSE .)
    STRING          reduce using rule 98 (expression -> FALSE .)
    TRUE            reduce using rule 98 (expression -> FALSE .)
    FALSE           reduce using rule 98 (expression -> FALSE .)
    NIL             reduce using rule 98 (expression -> FALSE .)
    $end            reduce using rule 98 (expression -> FALSE .)
    LBRACE          reduce using rule 98 (expression -> FALSE .)
    ELSE            reduce using rule 98 (expression -> FALSE .)
    RPAREN          reduce using rule 98 (expression -> FALSE .)
    COMMA           reduce using rule 98 (expression -> FALSE .)
    RBRACE          reduce using rule 98 (expression -> FALSE .)
    DEFAULT         reduce using rule 98 (expression -> FALSE .)
    CASE            reduce using rule 98 (expression -> FALSE .)
    COLON           reduce using rule 98 (expression -> FALSE .)
    RBRACKET        reduce using rule 98 (expression -> FALSE .)
    CLOSED_RANGE    reduce using rule 98 (expression -> FALSE .)
    HALF_OPEN_RANGE reduce using rule 98 (expression -> FALSE .)


state 49

    (99) expression -> NIL .

    LBRACKET        reduce using rule 99 (expression -> NIL .)
    DOT             reduce using rule 99 (expression -> NIL .)
    PLUS            reduce using rule 99 (expression -> NIL .)
    MINUS           reduce using rule 99 (expression -> NIL .)
    TIMES           reduce using rule 99 (expression -> NIL .)
    DIVIDE          reduce using rule 99 (expression -> NIL .)
    MODULO          reduce using rule 99 (expression -> NIL .)
    AND             reduce using rule 99 (expression -> NIL .)
    OR              reduce using rule 99 (expression -> NIL .)
    EQ              reduce using rule 99 (expression -> NIL .)
    NE              reduce using rule 99 (expression -> NIL .)
    GT              reduce using rule 99 (expression -> NIL .)
    LT              reduce using rule 99 (expression -> NIL .)
    GE              reduce using rule 99 (expression -> NIL .)
    LE              reduce using rule 99 (expression -> NIL .)
    QUESTION        reduce using rule 99 (expression -> NIL .)
    NIL_COALESCE    reduce using rule 99 (expression -> NIL .)
    NEWLINE         reduce using rule 99 (expression -> NIL .)
    LET             reduce using rule 99 (expression -> NIL .)
    VAR             reduce using rule 99 (expression -> NIL .)
    IF              reduce using rule 99 (expression -> NIL .)
    GUARD           reduce using rule 99 (expression -> NIL .)
    SWITCH          reduce using rule 99 (expression -> NIL .)
    IDENTIFIER      reduce using rule 99 (expression -> NIL .)
    RETURN          reduce using rule 99 (expression -> NIL .)
    BREAK           reduce using rule 99 (expression -> NIL .)
    CONTINUE        reduce using rule 99 (expression -> NIL .)
    SELF            reduce using rule 99 (expression -> NIL .)
    FOR             reduce using rule 99 (expression -> NIL .)
    WHILE           reduce using rule 99 (expression -> NIL .)
    FUNC            reduce using rule 99 (expression -> NIL .)
    CLASS           reduce using rule 99 (expression -> NIL .)
    LPAREN          reduce using rule 99 (expression -> NIL .)
    NOT             reduce using rule 99 (expression -> NIL .)
    INT_LITERAL     reduce using rule 99 (expression -> NIL .)
    FLOAT_LITERAL   reduce using rule 99 (expression -> NIL .)
    STRING          reduce using rule 99 (expression -> NIL .)
    TRUE            reduce using rule 99 (expression -> NIL .)
    FALSE           reduce using rule 99 (expression -> NIL .)
    NIL             reduce using rule 99 (expression -> NIL .)
    $end            reduce using rule 99 (expression -> NIL .)
    LBRACE          reduce using rule 99 (expression -> NIL .)
    ELSE            reduce using rule 99 (expression -> NIL .)
    RPAREN          reduce using rule 99 (expression -> NIL .)
    COMMA           reduce using rule 99 (expression -> NIL .)
    RBRACE          reduce using rule 99 (expression -> NIL .)
    DEFAULT         reduce using rule 99 (expression -> NIL .)
    CASE            reduce using rule 99 (expression -> NIL .)
    COLON           reduce using rule 99 (expression -> NIL .)
    RBRACKET        reduce using rule 99 (expression -> NIL .)
    CLOSED_RANGE    reduce using rule 99 (expression -> NIL .)
    HALF_OPEN_RANGE reduce using rule 99 (expression -> NIL .)


state 50

    (2) statement_list -> statement_list statement .

    NEWLINE         reduce using rule 2 (statement_list -> statement_list statement .)
    LET             reduce using rule 2 (statement_list -> statement_list statement .)
    VAR             reduce using rule 2 (statement_list -> statement_list statement .)
    IF              reduce using rule 2 (statement_list -> statement_list statement .)
    GUARD           reduce using rule 2 (statement_list -> statement_list statement .)
    SWITCH          reduce using rule 2 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 2 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 2 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 2 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 2 (statement_list -> statement_list statement .)
    SELF            reduce using rule 2 (statement_list -> statement_list statement .)
    FOR             reduce using rule 2 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 2 (statement_list -> statement_list statement .)
    FUNC            reduce using rule 2 (statement_list -> statement_list statement .)
    CLASS           reduce using rule 2 (statement_list -> statement_list statement .)
    LBRACKET        reduce using rule 2 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 2 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 2 (statement_list -> statement_list statement .)
    PLUS            reduce using rule 2 (statement_list -> statement_list statement .)
    NOT             reduce using rule 2 (statement_list -> statement_list statement .)
    INT_LITERAL     reduce using rule 2 (statement_list -> statement_list statement .)
    FLOAT_LITERAL   reduce using rule 2 (statement_list -> statement_list statement .)
    STRING          reduce using rule 2 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 2 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 2 (statement_list -> statement_list statement .)
    NIL             reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement_list statement .)
    DEFAULT         reduce using rule 2 (statement_list -> statement_list statement .)
    CASE            reduce using rule 2 (statement_list -> statement_list statement .)


state 51

    (20) variable_declaration -> LET IDENTIFIER . COLON type_annotation ASSIGN expression
    (22) variable_declaration -> LET IDENTIFIER . ASSIGN expression
    (24) variable_declaration -> LET IDENTIFIER . COLON type_annotation
    (26) variable_declaration -> LET IDENTIFIER . COLON tuple_type

    COLON           shift and go to state 107
    ASSIGN          shift and go to state 108


state 52

    (143) function_call_statement -> IDENTIFIER LPAREN . argument_list RPAREN
    (144) function_call_statement -> IDENTIFIER LPAREN . RPAREN
    (102) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (103) expression -> IDENTIFIER LPAREN . RPAREN
    (145) argument_list -> . argument_list COMMA expression
    (146) argument_list -> . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RPAREN          shift and go to state 110
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    argument_list                  shift and go to state 109
    expression                     shift and go to state 111

state 53

    (46) expression -> expression LBRACKET . expression RBRACKET
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 112

state 54

    (63) expression -> expression DOT . INT_LITERAL
    (64) expression -> expression DOT . IDENTIFIER

    INT_LITERAL     shift and go to state 113
    IDENTIFIER      shift and go to state 114


state 55

    (75) expression -> expression PLUS . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 115

state 56

    (76) expression -> expression MINUS . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 116

state 57

    (77) expression -> expression TIMES . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 117

state 58

    (78) expression -> expression DIVIDE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 118

state 59

    (79) expression -> expression MODULO . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 119

state 60

    (82) expression -> expression AND . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 120

state 61

    (83) expression -> expression OR . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 121

state 62

    (85) expression -> expression EQ . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 122

state 63

    (86) expression -> expression NE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 123

state 64

    (87) expression -> expression GT . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 124

state 65

    (88) expression -> expression LT . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 125

state 66

    (89) expression -> expression GE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 126

state 67

    (90) expression -> expression LE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 127

state 68

    (91) expression -> expression QUESTION . expression COLON expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 128

state 69

    (92) expression -> expression NIL_COALESCE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 129

state 70

    (21) variable_declaration -> VAR IDENTIFIER . COLON type_annotation ASSIGN expression
    (23) variable_declaration -> VAR IDENTIFIER . ASSIGN expression
    (25) variable_declaration -> VAR IDENTIFIER . COLON type_annotation
    (27) variable_declaration -> VAR IDENTIFIER . COLON tuple_type

    COLON           shift and go to state 130
    ASSIGN          shift and go to state 131


state 71

    (65) assignment -> lvalue ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 132

state 72

    (66) assignment -> lvalue PLUS_ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 133

state 73

    (67) assignment -> lvalue MINUS_ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 134

state 74

    (68) assignment -> lvalue TIMES_ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 135

state 75

    (69) assignment -> lvalue DIV_ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 136

state 76

    (70) assignment -> lvalue MOD_ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 137

state 77

    (73) lvalue -> lvalue DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 138


state 78

    (74) lvalue -> lvalue LBRACKET . expression RBRACKET
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 139

state 79

    (104) for_statement -> for_header LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    for_header                     shift and go to state 24
    statement_list                 shift and go to state 140
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 80

    (109) if_statement -> IF expression . LBRACE statement_list RBRACE
    (110) if_statement -> IF expression . LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> IF expression . LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> IF expression . LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          shift and go to state 141
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 81

    (100) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (103) expression -> IDENTIFIER . LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          reduce using rule 100 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 100 (expression -> IDENTIFIER .)
    DOT             reduce using rule 100 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 100 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 100 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 100 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (expression -> IDENTIFIER .)
    MODULO          reduce using rule 100 (expression -> IDENTIFIER .)
    AND             reduce using rule 100 (expression -> IDENTIFIER .)
    OR              reduce using rule 100 (expression -> IDENTIFIER .)
    EQ              reduce using rule 100 (expression -> IDENTIFIER .)
    NE              reduce using rule 100 (expression -> IDENTIFIER .)
    GT              reduce using rule 100 (expression -> IDENTIFIER .)
    LT              reduce using rule 100 (expression -> IDENTIFIER .)
    GE              reduce using rule 100 (expression -> IDENTIFIER .)
    LE              reduce using rule 100 (expression -> IDENTIFIER .)
    QUESTION        reduce using rule 100 (expression -> IDENTIFIER .)
    NIL_COALESCE    reduce using rule 100 (expression -> IDENTIFIER .)
    ELSE            reduce using rule 100 (expression -> IDENTIFIER .)
    NEWLINE         reduce using rule 100 (expression -> IDENTIFIER .)
    LET             reduce using rule 100 (expression -> IDENTIFIER .)
    VAR             reduce using rule 100 (expression -> IDENTIFIER .)
    IF              reduce using rule 100 (expression -> IDENTIFIER .)
    GUARD           reduce using rule 100 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 100 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 100 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 100 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 100 (expression -> IDENTIFIER .)
    SELF            reduce using rule 100 (expression -> IDENTIFIER .)
    FOR             reduce using rule 100 (expression -> IDENTIFIER .)
    WHILE           reduce using rule 100 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 100 (expression -> IDENTIFIER .)
    CLASS           reduce using rule 100 (expression -> IDENTIFIER .)
    NOT             reduce using rule 100 (expression -> IDENTIFIER .)
    INT_LITERAL     reduce using rule 100 (expression -> IDENTIFIER .)
    FLOAT_LITERAL   reduce using rule 100 (expression -> IDENTIFIER .)
    STRING          reduce using rule 100 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 100 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 100 (expression -> IDENTIFIER .)
    NIL             reduce using rule 100 (expression -> IDENTIFIER .)
    $end            reduce using rule 100 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 100 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 100 (expression -> IDENTIFIER .)
    CASE            reduce using rule 100 (expression -> IDENTIFIER .)
    COLON           reduce using rule 100 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 100 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 100 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 100 (expression -> IDENTIFIER .)
    CLOSED_RANGE    reduce using rule 100 (expression -> IDENTIFIER .)
    HALF_OPEN_RANGE reduce using rule 100 (expression -> IDENTIFIER .)
    LPAREN          shift and go to state 142

  ! LPAREN          [ reduce using rule 100 (expression -> IDENTIFIER .) ]


state 82

    (101) expression -> SELF . DOT IDENTIFIER

    DOT             shift and go to state 143


state 83

    (116) guard_statement -> GUARD expression . ELSE LBRACE statement_list RBRACE
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    ELSE            shift and go to state 144
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 84

    (117) while_statement -> while_header LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    while_header                   shift and go to state 27
    statement_list                 shift and go to state 145
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 85

    (121) switch_statement -> SWITCH expression . LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> SWITCH expression . LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          shift and go to state 146
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 86

    (132) function_declaration -> func_header LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    func_header                    shift and go to state 29
    statement_list                 shift and go to state 147
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    class_header                   shift and go to state 31

state 87

    (58) expression -> LPAREN tuple_elements . RPAREN
    (59) tuple_elements -> tuple_elements . COMMA tuple_element

    RPAREN          shift and go to state 148
    COMMA           shift and go to state 149


state 88

    (93) expression -> LPAREN expression . RPAREN
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression
    (62) tuple_element -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 150
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69
    COMMA           reduce using rule 62 (tuple_element -> expression .)

  ! RPAREN          [ reduce using rule 62 (tuple_element -> expression .) ]


state 89

    (60) tuple_elements -> tuple_element .

    RPAREN          reduce using rule 60 (tuple_elements -> tuple_element .)
    COMMA           reduce using rule 60 (tuple_elements -> tuple_element .)


state 90

    (100) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (103) expression -> IDENTIFIER . LPAREN RPAREN
    (61) tuple_element -> IDENTIFIER . COLON expression

    RPAREN          reduce using rule 100 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 100 (expression -> IDENTIFIER .)
    DOT             reduce using rule 100 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 100 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 100 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 100 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (expression -> IDENTIFIER .)
    MODULO          reduce using rule 100 (expression -> IDENTIFIER .)
    AND             reduce using rule 100 (expression -> IDENTIFIER .)
    OR              reduce using rule 100 (expression -> IDENTIFIER .)
    EQ              reduce using rule 100 (expression -> IDENTIFIER .)
    NE              reduce using rule 100 (expression -> IDENTIFIER .)
    GT              reduce using rule 100 (expression -> IDENTIFIER .)
    LT              reduce using rule 100 (expression -> IDENTIFIER .)
    GE              reduce using rule 100 (expression -> IDENTIFIER .)
    LE              reduce using rule 100 (expression -> IDENTIFIER .)
    QUESTION        reduce using rule 100 (expression -> IDENTIFIER .)
    NIL_COALESCE    reduce using rule 100 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 100 (expression -> IDENTIFIER .)
    LPAREN          shift and go to state 142
    COLON           shift and go to state 151


state 91

    (147) class_declaration -> class_header LBRACE . class_body RBRACE
    (149) class_body -> . class_body class_member
    (150) class_body -> . class_member
    (151) class_body -> . empty
    (152) class_member -> . property_declaration
    (153) class_member -> . init_declaration
    (154) class_member -> . method_declaration
    (155) class_member -> . computed_property
    (156) class_member -> . NEWLINE
    (170) empty -> .
    (157) property_declaration -> . VAR IDENTIFIER COLON type_annotation
    (158) property_declaration -> . LET IDENTIFIER COLON type_annotation
    (159) property_declaration -> . VAR IDENTIFIER COLON tuple_type
    (160) property_declaration -> . LET IDENTIFIER COLON tuple_type
    (162) init_declaration -> . init_header LBRACE statement_list RBRACE
    (165) method_declaration -> . method_header LBRACE statement_list RBRACE
    (161) computed_property -> . VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
    (163) init_header -> . INIT LPAREN parameter_list RPAREN
    (164) init_header -> . INIT LPAREN RPAREN
    (166) method_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (167) method_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (168) method_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (169) method_header -> . FUNC IDENTIFIER LPAREN RPAREN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for INIT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
    NEWLINE         shift and go to state 159
    RBRACE          reduce using rule 170 (empty -> .)
    VAR             shift and go to state 160
    LET             shift and go to state 161
    INIT            shift and go to state 164
    FUNC            shift and go to state 165

  ! NEWLINE         [ reduce using rule 170 (empty -> .) ]
  ! VAR             [ reduce using rule 170 (empty -> .) ]
  ! LET             [ reduce using rule 170 (empty -> .) ]
  ! INIT            [ reduce using rule 170 (empty -> .) ]
  ! FUNC            [ reduce using rule 170 (empty -> .) ]

    class_body                     shift and go to state 152
    class_member                   shift and go to state 153
    empty                          shift and go to state 154
    property_declaration           shift and go to state 155
    init_declaration               shift and go to state 156
    method_declaration             shift and go to state 157
    computed_property              shift and go to state 158
    init_header                    shift and go to state 162
    method_header                  shift and go to state 163

state 92

    (141) return_statement -> RETURN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 141 (return_statement -> RETURN expression .)
    LET             reduce using rule 141 (return_statement -> RETURN expression .)
    VAR             reduce using rule 141 (return_statement -> RETURN expression .)
    IF              reduce using rule 141 (return_statement -> RETURN expression .)
    GUARD           reduce using rule 141 (return_statement -> RETURN expression .)
    SWITCH          reduce using rule 141 (return_statement -> RETURN expression .)
    IDENTIFIER      reduce using rule 141 (return_statement -> RETURN expression .)
    RETURN          reduce using rule 141 (return_statement -> RETURN expression .)
    BREAK           reduce using rule 141 (return_statement -> RETURN expression .)
    CONTINUE        reduce using rule 141 (return_statement -> RETURN expression .)
    SELF            reduce using rule 141 (return_statement -> RETURN expression .)
    FOR             reduce using rule 141 (return_statement -> RETURN expression .)
    WHILE           reduce using rule 141 (return_statement -> RETURN expression .)
    FUNC            reduce using rule 141 (return_statement -> RETURN expression .)
    CLASS           reduce using rule 141 (return_statement -> RETURN expression .)
    LPAREN          reduce using rule 141 (return_statement -> RETURN expression .)
    NOT             reduce using rule 141 (return_statement -> RETURN expression .)
    INT_LITERAL     reduce using rule 141 (return_statement -> RETURN expression .)
    FLOAT_LITERAL   reduce using rule 141 (return_statement -> RETURN expression .)
    STRING          reduce using rule 141 (return_statement -> RETURN expression .)
    TRUE            reduce using rule 141 (return_statement -> RETURN expression .)
    FALSE           reduce using rule 141 (return_statement -> RETURN expression .)
    NIL             reduce using rule 141 (return_statement -> RETURN expression .)
    $end            reduce using rule 141 (return_statement -> RETURN expression .)
    RBRACE          reduce using rule 141 (return_statement -> RETURN expression .)
    DEFAULT         reduce using rule 141 (return_statement -> RETURN expression .)
    CASE            reduce using rule 141 (return_statement -> RETURN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 141 (return_statement -> RETURN expression .) ]
  ! MINUS           [ reduce using rule 141 (return_statement -> RETURN expression .) ]
  ! PLUS            [ reduce using rule 141 (return_statement -> RETURN expression .) ]


state 93

    (72) lvalue -> SELF DOT . IDENTIFIER
    (101) expression -> SELF DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 166


state 94

    (42) expression -> LBRACKET array_elements . RBRACKET
    (44) array_elements -> array_elements . COMMA expression

    RBRACKET        shift and go to state 167
    COMMA           shift and go to state 168


state 95

    (43) expression -> LBRACKET RBRACKET .

    LBRACKET        reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    DOT             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    PLUS            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    TIMES           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    MODULO          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    AND             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    OR              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    EQ              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    NE              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    GT              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    LT              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    GE              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    LE              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    QUESTION        reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    NIL_COALESCE    reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    NEWLINE         reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    LET             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    VAR             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    IF              reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    GUARD           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    SWITCH          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    BREAK           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    CONTINUE        reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    SELF            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    FOR             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    FUNC            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    CLASS           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    NOT             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    INT_LITERAL     reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    FLOAT_LITERAL   reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    STRING          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    TRUE            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    FALSE           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    NIL             reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    $end            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    LBRACE          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    ELSE            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    DEFAULT         reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    CASE            reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    COLON           reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    CLOSED_RANGE    reduce using rule 43 (expression -> LBRACKET RBRACKET .)
    HALF_OPEN_RANGE reduce using rule 43 (expression -> LBRACKET RBRACKET .)


state 96

    (48) expression -> LBRACKET dictionary_pairs . RBRACKET
    (50) dictionary_pairs -> dictionary_pairs . COMMA dictionary_pair

    RBRACKET        shift and go to state 169
    COMMA           shift and go to state 170


state 97

    (49) expression -> LBRACKET COLON . RBRACKET

    RBRACKET        shift and go to state 171


state 98

    (45) array_elements -> expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression
    (52) dictionary_pair -> expression . COLON expression

    RBRACKET        reduce using rule 45 (array_elements -> expression .)
    COMMA           reduce using rule 45 (array_elements -> expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69
    COLON           shift and go to state 172


state 99

    (51) dictionary_pairs -> dictionary_pair .

    RBRACKET        reduce using rule 51 (dictionary_pairs -> dictionary_pair .)
    COMMA           reduce using rule 51 (dictionary_pairs -> dictionary_pair .)


state 100

    (105) for_header -> FOR IDENTIFIER . IN range_expression
    (106) for_header -> FOR IDENTIFIER . IN expression

    IN              shift and go to state 173


state 101

    (118) while_header -> WHILE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          reduce using rule 118 (while_header -> WHILE expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 102

    (133) func_header -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> FUNC IDENTIFIER . LPAREN RPAREN ARROW type_annotation
    (135) func_header -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN
    (136) func_header -> FUNC IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 174


state 103

    (148) class_header -> CLASS IDENTIFIER .

    LBRACE          reduce using rule 148 (class_header -> CLASS IDENTIFIER .)


state 104

    (81) expression -> PLUS expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 81 (expression -> PLUS expression .)
    DOT             reduce using rule 81 (expression -> PLUS expression .)
    PLUS            reduce using rule 81 (expression -> PLUS expression .)
    MINUS           reduce using rule 81 (expression -> PLUS expression .)
    TIMES           reduce using rule 81 (expression -> PLUS expression .)
    DIVIDE          reduce using rule 81 (expression -> PLUS expression .)
    MODULO          reduce using rule 81 (expression -> PLUS expression .)
    AND             reduce using rule 81 (expression -> PLUS expression .)
    OR              reduce using rule 81 (expression -> PLUS expression .)
    EQ              reduce using rule 81 (expression -> PLUS expression .)
    NE              reduce using rule 81 (expression -> PLUS expression .)
    GT              reduce using rule 81 (expression -> PLUS expression .)
    LT              reduce using rule 81 (expression -> PLUS expression .)
    GE              reduce using rule 81 (expression -> PLUS expression .)
    LE              reduce using rule 81 (expression -> PLUS expression .)
    QUESTION        reduce using rule 81 (expression -> PLUS expression .)
    NIL_COALESCE    reduce using rule 81 (expression -> PLUS expression .)
    NEWLINE         reduce using rule 81 (expression -> PLUS expression .)
    LET             reduce using rule 81 (expression -> PLUS expression .)
    VAR             reduce using rule 81 (expression -> PLUS expression .)
    IF              reduce using rule 81 (expression -> PLUS expression .)
    GUARD           reduce using rule 81 (expression -> PLUS expression .)
    SWITCH          reduce using rule 81 (expression -> PLUS expression .)
    IDENTIFIER      reduce using rule 81 (expression -> PLUS expression .)
    RETURN          reduce using rule 81 (expression -> PLUS expression .)
    BREAK           reduce using rule 81 (expression -> PLUS expression .)
    CONTINUE        reduce using rule 81 (expression -> PLUS expression .)
    SELF            reduce using rule 81 (expression -> PLUS expression .)
    FOR             reduce using rule 81 (expression -> PLUS expression .)
    WHILE           reduce using rule 81 (expression -> PLUS expression .)
    FUNC            reduce using rule 81 (expression -> PLUS expression .)
    CLASS           reduce using rule 81 (expression -> PLUS expression .)
    LPAREN          reduce using rule 81 (expression -> PLUS expression .)
    NOT             reduce using rule 81 (expression -> PLUS expression .)
    INT_LITERAL     reduce using rule 81 (expression -> PLUS expression .)
    FLOAT_LITERAL   reduce using rule 81 (expression -> PLUS expression .)
    STRING          reduce using rule 81 (expression -> PLUS expression .)
    TRUE            reduce using rule 81 (expression -> PLUS expression .)
    FALSE           reduce using rule 81 (expression -> PLUS expression .)
    NIL             reduce using rule 81 (expression -> PLUS expression .)
    $end            reduce using rule 81 (expression -> PLUS expression .)
    LBRACE          reduce using rule 81 (expression -> PLUS expression .)
    ELSE            reduce using rule 81 (expression -> PLUS expression .)
    RPAREN          reduce using rule 81 (expression -> PLUS expression .)
    COMMA           reduce using rule 81 (expression -> PLUS expression .)
    RBRACE          reduce using rule 81 (expression -> PLUS expression .)
    DEFAULT         reduce using rule 81 (expression -> PLUS expression .)
    CASE            reduce using rule 81 (expression -> PLUS expression .)
    COLON           reduce using rule 81 (expression -> PLUS expression .)
    RBRACKET        reduce using rule 81 (expression -> PLUS expression .)
    CLOSED_RANGE    reduce using rule 81 (expression -> PLUS expression .)
    HALF_OPEN_RANGE reduce using rule 81 (expression -> PLUS expression .)

  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! TIMES           [ shift and go to state 57 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULO          [ shift and go to state 59 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 105

    (80) expression -> MINUS expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 80 (expression -> MINUS expression .)
    DOT             reduce using rule 80 (expression -> MINUS expression .)
    PLUS            reduce using rule 80 (expression -> MINUS expression .)
    MINUS           reduce using rule 80 (expression -> MINUS expression .)
    TIMES           reduce using rule 80 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 80 (expression -> MINUS expression .)
    MODULO          reduce using rule 80 (expression -> MINUS expression .)
    AND             reduce using rule 80 (expression -> MINUS expression .)
    OR              reduce using rule 80 (expression -> MINUS expression .)
    EQ              reduce using rule 80 (expression -> MINUS expression .)
    NE              reduce using rule 80 (expression -> MINUS expression .)
    GT              reduce using rule 80 (expression -> MINUS expression .)
    LT              reduce using rule 80 (expression -> MINUS expression .)
    GE              reduce using rule 80 (expression -> MINUS expression .)
    LE              reduce using rule 80 (expression -> MINUS expression .)
    QUESTION        reduce using rule 80 (expression -> MINUS expression .)
    NIL_COALESCE    reduce using rule 80 (expression -> MINUS expression .)
    NEWLINE         reduce using rule 80 (expression -> MINUS expression .)
    LET             reduce using rule 80 (expression -> MINUS expression .)
    VAR             reduce using rule 80 (expression -> MINUS expression .)
    IF              reduce using rule 80 (expression -> MINUS expression .)
    GUARD           reduce using rule 80 (expression -> MINUS expression .)
    SWITCH          reduce using rule 80 (expression -> MINUS expression .)
    IDENTIFIER      reduce using rule 80 (expression -> MINUS expression .)
    RETURN          reduce using rule 80 (expression -> MINUS expression .)
    BREAK           reduce using rule 80 (expression -> MINUS expression .)
    CONTINUE        reduce using rule 80 (expression -> MINUS expression .)
    SELF            reduce using rule 80 (expression -> MINUS expression .)
    FOR             reduce using rule 80 (expression -> MINUS expression .)
    WHILE           reduce using rule 80 (expression -> MINUS expression .)
    FUNC            reduce using rule 80 (expression -> MINUS expression .)
    CLASS           reduce using rule 80 (expression -> MINUS expression .)
    LPAREN          reduce using rule 80 (expression -> MINUS expression .)
    NOT             reduce using rule 80 (expression -> MINUS expression .)
    INT_LITERAL     reduce using rule 80 (expression -> MINUS expression .)
    FLOAT_LITERAL   reduce using rule 80 (expression -> MINUS expression .)
    STRING          reduce using rule 80 (expression -> MINUS expression .)
    TRUE            reduce using rule 80 (expression -> MINUS expression .)
    FALSE           reduce using rule 80 (expression -> MINUS expression .)
    NIL             reduce using rule 80 (expression -> MINUS expression .)
    $end            reduce using rule 80 (expression -> MINUS expression .)
    LBRACE          reduce using rule 80 (expression -> MINUS expression .)
    ELSE            reduce using rule 80 (expression -> MINUS expression .)
    RPAREN          reduce using rule 80 (expression -> MINUS expression .)
    COMMA           reduce using rule 80 (expression -> MINUS expression .)
    RBRACE          reduce using rule 80 (expression -> MINUS expression .)
    DEFAULT         reduce using rule 80 (expression -> MINUS expression .)
    CASE            reduce using rule 80 (expression -> MINUS expression .)
    COLON           reduce using rule 80 (expression -> MINUS expression .)
    RBRACKET        reduce using rule 80 (expression -> MINUS expression .)
    CLOSED_RANGE    reduce using rule 80 (expression -> MINUS expression .)
    HALF_OPEN_RANGE reduce using rule 80 (expression -> MINUS expression .)

  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! TIMES           [ shift and go to state 57 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULO          [ shift and go to state 59 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 106

    (84) expression -> NOT expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 84 (expression -> NOT expression .)
    DOT             reduce using rule 84 (expression -> NOT expression .)
    PLUS            reduce using rule 84 (expression -> NOT expression .)
    MINUS           reduce using rule 84 (expression -> NOT expression .)
    TIMES           reduce using rule 84 (expression -> NOT expression .)
    DIVIDE          reduce using rule 84 (expression -> NOT expression .)
    MODULO          reduce using rule 84 (expression -> NOT expression .)
    AND             reduce using rule 84 (expression -> NOT expression .)
    OR              reduce using rule 84 (expression -> NOT expression .)
    EQ              reduce using rule 84 (expression -> NOT expression .)
    NE              reduce using rule 84 (expression -> NOT expression .)
    GT              reduce using rule 84 (expression -> NOT expression .)
    LT              reduce using rule 84 (expression -> NOT expression .)
    GE              reduce using rule 84 (expression -> NOT expression .)
    LE              reduce using rule 84 (expression -> NOT expression .)
    QUESTION        reduce using rule 84 (expression -> NOT expression .)
    NIL_COALESCE    reduce using rule 84 (expression -> NOT expression .)
    NEWLINE         reduce using rule 84 (expression -> NOT expression .)
    LET             reduce using rule 84 (expression -> NOT expression .)
    VAR             reduce using rule 84 (expression -> NOT expression .)
    IF              reduce using rule 84 (expression -> NOT expression .)
    GUARD           reduce using rule 84 (expression -> NOT expression .)
    SWITCH          reduce using rule 84 (expression -> NOT expression .)
    IDENTIFIER      reduce using rule 84 (expression -> NOT expression .)
    RETURN          reduce using rule 84 (expression -> NOT expression .)
    BREAK           reduce using rule 84 (expression -> NOT expression .)
    CONTINUE        reduce using rule 84 (expression -> NOT expression .)
    SELF            reduce using rule 84 (expression -> NOT expression .)
    FOR             reduce using rule 84 (expression -> NOT expression .)
    WHILE           reduce using rule 84 (expression -> NOT expression .)
    FUNC            reduce using rule 84 (expression -> NOT expression .)
    CLASS           reduce using rule 84 (expression -> NOT expression .)
    LPAREN          reduce using rule 84 (expression -> NOT expression .)
    NOT             reduce using rule 84 (expression -> NOT expression .)
    INT_LITERAL     reduce using rule 84 (expression -> NOT expression .)
    FLOAT_LITERAL   reduce using rule 84 (expression -> NOT expression .)
    STRING          reduce using rule 84 (expression -> NOT expression .)
    TRUE            reduce using rule 84 (expression -> NOT expression .)
    FALSE           reduce using rule 84 (expression -> NOT expression .)
    NIL             reduce using rule 84 (expression -> NOT expression .)
    $end            reduce using rule 84 (expression -> NOT expression .)
    LBRACE          reduce using rule 84 (expression -> NOT expression .)
    ELSE            reduce using rule 84 (expression -> NOT expression .)
    RPAREN          reduce using rule 84 (expression -> NOT expression .)
    COMMA           reduce using rule 84 (expression -> NOT expression .)
    RBRACE          reduce using rule 84 (expression -> NOT expression .)
    DEFAULT         reduce using rule 84 (expression -> NOT expression .)
    CASE            reduce using rule 84 (expression -> NOT expression .)
    COLON           reduce using rule 84 (expression -> NOT expression .)
    RBRACKET        reduce using rule 84 (expression -> NOT expression .)
    CLOSED_RANGE    reduce using rule 84 (expression -> NOT expression .)
    HALF_OPEN_RANGE reduce using rule 84 (expression -> NOT expression .)

  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! TIMES           [ shift and go to state 57 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULO          [ shift and go to state 59 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 107

    (20) variable_declaration -> LET IDENTIFIER COLON . type_annotation ASSIGN expression
    (24) variable_declaration -> LET IDENTIFIER COLON . type_annotation
    (26) variable_declaration -> LET IDENTIFIER COLON . tuple_type
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LPAREN          shift and go to state 185
    LBRACKET        shift and go to state 186

    type_annotation                shift and go to state 176
    tuple_type                     shift and go to state 177
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184

state 108

    (22) variable_declaration -> LET IDENTIFIER ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 187

state 109

    (143) function_call_statement -> IDENTIFIER LPAREN argument_list . RPAREN
    (102) expression -> IDENTIFIER LPAREN argument_list . RPAREN
    (145) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 188
    COMMA           shift and go to state 189


state 110

    (144) function_call_statement -> IDENTIFIER LPAREN RPAREN .
    (103) expression -> IDENTIFIER LPAREN RPAREN .

  ! reduce/reduce conflict for LBRACKET resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for PLUS resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for MINUS resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for LET resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for VAR resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for GUARD resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for SELF resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for WHILE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for CLASS resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for LPAREN resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for NOT resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for FLOAT_LITERAL resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for STRING resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for TRUE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for FALSE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for NIL resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LBRACKET        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    MODULO          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NE              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    QUESTION        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NIL_COALESCE    reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LET             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    GUARD           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    SWITCH          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CONTINUE        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    SELF            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FUNC            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CLASS           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NOT             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    INT_LITERAL     reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FLOAT_LITERAL   reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    STRING          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NIL             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    DEFAULT         reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CASE            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)

  ! NEWLINE         [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! LET             [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! VAR             [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! IF              [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! GUARD           [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! SWITCH          [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! RETURN          [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! BREAK           [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! CONTINUE        [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! SELF            [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! FOR             [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! WHILE           [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! FUNC            [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! CLASS           [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! LBRACKET        [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! LPAREN          [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! MINUS           [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! PLUS            [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! NOT             [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! INT_LITERAL     [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! FLOAT_LITERAL   [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! STRING          [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! TRUE            [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! FALSE           [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! NIL             [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! $end            [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! RBRACE          [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! DEFAULT         [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]
  ! CASE            [ reduce using rule 144 (function_call_statement -> IDENTIFIER LPAREN RPAREN .) ]


state 111

    (146) argument_list -> expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RPAREN          reduce using rule 146 (argument_list -> expression .)
    COMMA           reduce using rule 146 (argument_list -> expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 112

    (46) expression -> expression LBRACKET expression . RBRACKET
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RBRACKET        shift and go to state 190
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 113

    (63) expression -> expression DOT INT_LITERAL .

    LBRACKET        reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    DOT             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    PLUS            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    MINUS           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    TIMES           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    DIVIDE          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    MODULO          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    AND             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    OR              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    EQ              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    NE              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    GT              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    LT              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    GE              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    LE              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    QUESTION        reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    NIL_COALESCE    reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    NEWLINE         reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    LET             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    VAR             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    IF              reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    GUARD           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    SWITCH          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    IDENTIFIER      reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    RETURN          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    BREAK           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    CONTINUE        reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    SELF            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    FOR             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    WHILE           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    FUNC            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    CLASS           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    LPAREN          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    NOT             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    INT_LITERAL     reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    FLOAT_LITERAL   reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    STRING          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    TRUE            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    FALSE           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    NIL             reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    $end            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    LBRACE          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    ELSE            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    RPAREN          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    COMMA           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    RBRACE          reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    DEFAULT         reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    CASE            reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    COLON           reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    RBRACKET        reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    CLOSED_RANGE    reduce using rule 63 (expression -> expression DOT INT_LITERAL .)
    HALF_OPEN_RANGE reduce using rule 63 (expression -> expression DOT INT_LITERAL .)


state 114

    (64) expression -> expression DOT IDENTIFIER .

    LBRACKET        reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    DOT             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    PLUS            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    MINUS           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    TIMES           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    DIVIDE          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    MODULO          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    AND             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    OR              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    EQ              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    NE              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    GT              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    LT              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    GE              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    LE              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    QUESTION        reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    NIL_COALESCE    reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    NEWLINE         reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    LET             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    VAR             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    IF              reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    GUARD           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    SWITCH          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    RETURN          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    BREAK           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    CONTINUE        reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    SELF            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    FOR             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    WHILE           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    FUNC            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    CLASS           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    LPAREN          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    NOT             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    INT_LITERAL     reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    FLOAT_LITERAL   reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    STRING          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    TRUE            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    FALSE           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    NIL             reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    $end            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    ELSE            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    DEFAULT         reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    CASE            reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    COLON           reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    RBRACKET        reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    CLOSED_RANGE    reduce using rule 64 (expression -> expression DOT IDENTIFIER .)
    HALF_OPEN_RANGE reduce using rule 64 (expression -> expression DOT IDENTIFIER .)


state 115

    (75) expression -> expression PLUS expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 75 (expression -> expression PLUS expression .)
    DOT             reduce using rule 75 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 75 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 75 (expression -> expression PLUS expression .)
    AND             reduce using rule 75 (expression -> expression PLUS expression .)
    OR              reduce using rule 75 (expression -> expression PLUS expression .)
    EQ              reduce using rule 75 (expression -> expression PLUS expression .)
    NE              reduce using rule 75 (expression -> expression PLUS expression .)
    GT              reduce using rule 75 (expression -> expression PLUS expression .)
    LT              reduce using rule 75 (expression -> expression PLUS expression .)
    GE              reduce using rule 75 (expression -> expression PLUS expression .)
    LE              reduce using rule 75 (expression -> expression PLUS expression .)
    QUESTION        reduce using rule 75 (expression -> expression PLUS expression .)
    NIL_COALESCE    reduce using rule 75 (expression -> expression PLUS expression .)
    NEWLINE         reduce using rule 75 (expression -> expression PLUS expression .)
    LET             reduce using rule 75 (expression -> expression PLUS expression .)
    VAR             reduce using rule 75 (expression -> expression PLUS expression .)
    IF              reduce using rule 75 (expression -> expression PLUS expression .)
    GUARD           reduce using rule 75 (expression -> expression PLUS expression .)
    SWITCH          reduce using rule 75 (expression -> expression PLUS expression .)
    IDENTIFIER      reduce using rule 75 (expression -> expression PLUS expression .)
    RETURN          reduce using rule 75 (expression -> expression PLUS expression .)
    BREAK           reduce using rule 75 (expression -> expression PLUS expression .)
    CONTINUE        reduce using rule 75 (expression -> expression PLUS expression .)
    SELF            reduce using rule 75 (expression -> expression PLUS expression .)
    FOR             reduce using rule 75 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 75 (expression -> expression PLUS expression .)
    FUNC            reduce using rule 75 (expression -> expression PLUS expression .)
    CLASS           reduce using rule 75 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 75 (expression -> expression PLUS expression .)
    NOT             reduce using rule 75 (expression -> expression PLUS expression .)
    INT_LITERAL     reduce using rule 75 (expression -> expression PLUS expression .)
    FLOAT_LITERAL   reduce using rule 75 (expression -> expression PLUS expression .)
    STRING          reduce using rule 75 (expression -> expression PLUS expression .)
    TRUE            reduce using rule 75 (expression -> expression PLUS expression .)
    FALSE           reduce using rule 75 (expression -> expression PLUS expression .)
    NIL             reduce using rule 75 (expression -> expression PLUS expression .)
    $end            reduce using rule 75 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 75 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 75 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 75 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 75 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 75 (expression -> expression PLUS expression .)
    DEFAULT         reduce using rule 75 (expression -> expression PLUS expression .)
    CASE            reduce using rule 75 (expression -> expression PLUS expression .)
    COLON           reduce using rule 75 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 75 (expression -> expression PLUS expression .)
    CLOSED_RANGE    reduce using rule 75 (expression -> expression PLUS expression .)
    HALF_OPEN_RANGE reduce using rule 75 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59

  ! TIMES           [ reduce using rule 75 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 75 (expression -> expression PLUS expression .) ]
  ! MODULO          [ reduce using rule 75 (expression -> expression PLUS expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 116

    (76) expression -> expression MINUS expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 76 (expression -> expression MINUS expression .)
    DOT             reduce using rule 76 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 76 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 76 (expression -> expression MINUS expression .)
    AND             reduce using rule 76 (expression -> expression MINUS expression .)
    OR              reduce using rule 76 (expression -> expression MINUS expression .)
    EQ              reduce using rule 76 (expression -> expression MINUS expression .)
    NE              reduce using rule 76 (expression -> expression MINUS expression .)
    GT              reduce using rule 76 (expression -> expression MINUS expression .)
    LT              reduce using rule 76 (expression -> expression MINUS expression .)
    GE              reduce using rule 76 (expression -> expression MINUS expression .)
    LE              reduce using rule 76 (expression -> expression MINUS expression .)
    QUESTION        reduce using rule 76 (expression -> expression MINUS expression .)
    NIL_COALESCE    reduce using rule 76 (expression -> expression MINUS expression .)
    NEWLINE         reduce using rule 76 (expression -> expression MINUS expression .)
    LET             reduce using rule 76 (expression -> expression MINUS expression .)
    VAR             reduce using rule 76 (expression -> expression MINUS expression .)
    IF              reduce using rule 76 (expression -> expression MINUS expression .)
    GUARD           reduce using rule 76 (expression -> expression MINUS expression .)
    SWITCH          reduce using rule 76 (expression -> expression MINUS expression .)
    IDENTIFIER      reduce using rule 76 (expression -> expression MINUS expression .)
    RETURN          reduce using rule 76 (expression -> expression MINUS expression .)
    BREAK           reduce using rule 76 (expression -> expression MINUS expression .)
    CONTINUE        reduce using rule 76 (expression -> expression MINUS expression .)
    SELF            reduce using rule 76 (expression -> expression MINUS expression .)
    FOR             reduce using rule 76 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 76 (expression -> expression MINUS expression .)
    FUNC            reduce using rule 76 (expression -> expression MINUS expression .)
    CLASS           reduce using rule 76 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 76 (expression -> expression MINUS expression .)
    NOT             reduce using rule 76 (expression -> expression MINUS expression .)
    INT_LITERAL     reduce using rule 76 (expression -> expression MINUS expression .)
    FLOAT_LITERAL   reduce using rule 76 (expression -> expression MINUS expression .)
    STRING          reduce using rule 76 (expression -> expression MINUS expression .)
    TRUE            reduce using rule 76 (expression -> expression MINUS expression .)
    FALSE           reduce using rule 76 (expression -> expression MINUS expression .)
    NIL             reduce using rule 76 (expression -> expression MINUS expression .)
    $end            reduce using rule 76 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 76 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 76 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 76 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 76 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 76 (expression -> expression MINUS expression .)
    DEFAULT         reduce using rule 76 (expression -> expression MINUS expression .)
    CASE            reduce using rule 76 (expression -> expression MINUS expression .)
    COLON           reduce using rule 76 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 76 (expression -> expression MINUS expression .)
    CLOSED_RANGE    reduce using rule 76 (expression -> expression MINUS expression .)
    HALF_OPEN_RANGE reduce using rule 76 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59

  ! TIMES           [ reduce using rule 76 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 76 (expression -> expression MINUS expression .) ]
  ! MODULO          [ reduce using rule 76 (expression -> expression MINUS expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 117

    (77) expression -> expression TIMES expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 77 (expression -> expression TIMES expression .)
    DOT             reduce using rule 77 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 77 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 77 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 77 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 77 (expression -> expression TIMES expression .)
    MODULO          reduce using rule 77 (expression -> expression TIMES expression .)
    AND             reduce using rule 77 (expression -> expression TIMES expression .)
    OR              reduce using rule 77 (expression -> expression TIMES expression .)
    EQ              reduce using rule 77 (expression -> expression TIMES expression .)
    NE              reduce using rule 77 (expression -> expression TIMES expression .)
    GT              reduce using rule 77 (expression -> expression TIMES expression .)
    LT              reduce using rule 77 (expression -> expression TIMES expression .)
    GE              reduce using rule 77 (expression -> expression TIMES expression .)
    LE              reduce using rule 77 (expression -> expression TIMES expression .)
    QUESTION        reduce using rule 77 (expression -> expression TIMES expression .)
    NIL_COALESCE    reduce using rule 77 (expression -> expression TIMES expression .)
    NEWLINE         reduce using rule 77 (expression -> expression TIMES expression .)
    LET             reduce using rule 77 (expression -> expression TIMES expression .)
    VAR             reduce using rule 77 (expression -> expression TIMES expression .)
    IF              reduce using rule 77 (expression -> expression TIMES expression .)
    GUARD           reduce using rule 77 (expression -> expression TIMES expression .)
    SWITCH          reduce using rule 77 (expression -> expression TIMES expression .)
    IDENTIFIER      reduce using rule 77 (expression -> expression TIMES expression .)
    RETURN          reduce using rule 77 (expression -> expression TIMES expression .)
    BREAK           reduce using rule 77 (expression -> expression TIMES expression .)
    CONTINUE        reduce using rule 77 (expression -> expression TIMES expression .)
    SELF            reduce using rule 77 (expression -> expression TIMES expression .)
    FOR             reduce using rule 77 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 77 (expression -> expression TIMES expression .)
    FUNC            reduce using rule 77 (expression -> expression TIMES expression .)
    CLASS           reduce using rule 77 (expression -> expression TIMES expression .)
    LPAREN          reduce using rule 77 (expression -> expression TIMES expression .)
    NOT             reduce using rule 77 (expression -> expression TIMES expression .)
    INT_LITERAL     reduce using rule 77 (expression -> expression TIMES expression .)
    FLOAT_LITERAL   reduce using rule 77 (expression -> expression TIMES expression .)
    STRING          reduce using rule 77 (expression -> expression TIMES expression .)
    TRUE            reduce using rule 77 (expression -> expression TIMES expression .)
    FALSE           reduce using rule 77 (expression -> expression TIMES expression .)
    NIL             reduce using rule 77 (expression -> expression TIMES expression .)
    $end            reduce using rule 77 (expression -> expression TIMES expression .)
    LBRACE          reduce using rule 77 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 77 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 77 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 77 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 77 (expression -> expression TIMES expression .)
    DEFAULT         reduce using rule 77 (expression -> expression TIMES expression .)
    CASE            reduce using rule 77 (expression -> expression TIMES expression .)
    COLON           reduce using rule 77 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 77 (expression -> expression TIMES expression .)
    CLOSED_RANGE    reduce using rule 77 (expression -> expression TIMES expression .)
    HALF_OPEN_RANGE reduce using rule 77 (expression -> expression TIMES expression .)

  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! TIMES           [ shift and go to state 57 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULO          [ shift and go to state 59 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 118

    (78) expression -> expression DIVIDE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 78 (expression -> expression DIVIDE expression .)
    DOT             reduce using rule 78 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 78 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 78 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 78 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 78 (expression -> expression DIVIDE expression .)
    MODULO          reduce using rule 78 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 78 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 78 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 78 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 78 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 78 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 78 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 78 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 78 (expression -> expression DIVIDE expression .)
    QUESTION        reduce using rule 78 (expression -> expression DIVIDE expression .)
    NIL_COALESCE    reduce using rule 78 (expression -> expression DIVIDE expression .)
    NEWLINE         reduce using rule 78 (expression -> expression DIVIDE expression .)
    LET             reduce using rule 78 (expression -> expression DIVIDE expression .)
    VAR             reduce using rule 78 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 78 (expression -> expression DIVIDE expression .)
    GUARD           reduce using rule 78 (expression -> expression DIVIDE expression .)
    SWITCH          reduce using rule 78 (expression -> expression DIVIDE expression .)
    IDENTIFIER      reduce using rule 78 (expression -> expression DIVIDE expression .)
    RETURN          reduce using rule 78 (expression -> expression DIVIDE expression .)
    BREAK           reduce using rule 78 (expression -> expression DIVIDE expression .)
    CONTINUE        reduce using rule 78 (expression -> expression DIVIDE expression .)
    SELF            reduce using rule 78 (expression -> expression DIVIDE expression .)
    FOR             reduce using rule 78 (expression -> expression DIVIDE expression .)
    WHILE           reduce using rule 78 (expression -> expression DIVIDE expression .)
    FUNC            reduce using rule 78 (expression -> expression DIVIDE expression .)
    CLASS           reduce using rule 78 (expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 78 (expression -> expression DIVIDE expression .)
    NOT             reduce using rule 78 (expression -> expression DIVIDE expression .)
    INT_LITERAL     reduce using rule 78 (expression -> expression DIVIDE expression .)
    FLOAT_LITERAL   reduce using rule 78 (expression -> expression DIVIDE expression .)
    STRING          reduce using rule 78 (expression -> expression DIVIDE expression .)
    TRUE            reduce using rule 78 (expression -> expression DIVIDE expression .)
    FALSE           reduce using rule 78 (expression -> expression DIVIDE expression .)
    NIL             reduce using rule 78 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 78 (expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 78 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 78 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 78 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 78 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 78 (expression -> expression DIVIDE expression .)
    DEFAULT         reduce using rule 78 (expression -> expression DIVIDE expression .)
    CASE            reduce using rule 78 (expression -> expression DIVIDE expression .)
    COLON           reduce using rule 78 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 78 (expression -> expression DIVIDE expression .)
    CLOSED_RANGE    reduce using rule 78 (expression -> expression DIVIDE expression .)
    HALF_OPEN_RANGE reduce using rule 78 (expression -> expression DIVIDE expression .)

  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! TIMES           [ shift and go to state 57 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULO          [ shift and go to state 59 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 119

    (79) expression -> expression MODULO expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 79 (expression -> expression MODULO expression .)
    DOT             reduce using rule 79 (expression -> expression MODULO expression .)
    PLUS            reduce using rule 79 (expression -> expression MODULO expression .)
    MINUS           reduce using rule 79 (expression -> expression MODULO expression .)
    TIMES           reduce using rule 79 (expression -> expression MODULO expression .)
    DIVIDE          reduce using rule 79 (expression -> expression MODULO expression .)
    MODULO          reduce using rule 79 (expression -> expression MODULO expression .)
    AND             reduce using rule 79 (expression -> expression MODULO expression .)
    OR              reduce using rule 79 (expression -> expression MODULO expression .)
    EQ              reduce using rule 79 (expression -> expression MODULO expression .)
    NE              reduce using rule 79 (expression -> expression MODULO expression .)
    GT              reduce using rule 79 (expression -> expression MODULO expression .)
    LT              reduce using rule 79 (expression -> expression MODULO expression .)
    GE              reduce using rule 79 (expression -> expression MODULO expression .)
    LE              reduce using rule 79 (expression -> expression MODULO expression .)
    QUESTION        reduce using rule 79 (expression -> expression MODULO expression .)
    NIL_COALESCE    reduce using rule 79 (expression -> expression MODULO expression .)
    NEWLINE         reduce using rule 79 (expression -> expression MODULO expression .)
    LET             reduce using rule 79 (expression -> expression MODULO expression .)
    VAR             reduce using rule 79 (expression -> expression MODULO expression .)
    IF              reduce using rule 79 (expression -> expression MODULO expression .)
    GUARD           reduce using rule 79 (expression -> expression MODULO expression .)
    SWITCH          reduce using rule 79 (expression -> expression MODULO expression .)
    IDENTIFIER      reduce using rule 79 (expression -> expression MODULO expression .)
    RETURN          reduce using rule 79 (expression -> expression MODULO expression .)
    BREAK           reduce using rule 79 (expression -> expression MODULO expression .)
    CONTINUE        reduce using rule 79 (expression -> expression MODULO expression .)
    SELF            reduce using rule 79 (expression -> expression MODULO expression .)
    FOR             reduce using rule 79 (expression -> expression MODULO expression .)
    WHILE           reduce using rule 79 (expression -> expression MODULO expression .)
    FUNC            reduce using rule 79 (expression -> expression MODULO expression .)
    CLASS           reduce using rule 79 (expression -> expression MODULO expression .)
    LPAREN          reduce using rule 79 (expression -> expression MODULO expression .)
    NOT             reduce using rule 79 (expression -> expression MODULO expression .)
    INT_LITERAL     reduce using rule 79 (expression -> expression MODULO expression .)
    FLOAT_LITERAL   reduce using rule 79 (expression -> expression MODULO expression .)
    STRING          reduce using rule 79 (expression -> expression MODULO expression .)
    TRUE            reduce using rule 79 (expression -> expression MODULO expression .)
    FALSE           reduce using rule 79 (expression -> expression MODULO expression .)
    NIL             reduce using rule 79 (expression -> expression MODULO expression .)
    $end            reduce using rule 79 (expression -> expression MODULO expression .)
    LBRACE          reduce using rule 79 (expression -> expression MODULO expression .)
    ELSE            reduce using rule 79 (expression -> expression MODULO expression .)
    RPAREN          reduce using rule 79 (expression -> expression MODULO expression .)
    COMMA           reduce using rule 79 (expression -> expression MODULO expression .)
    RBRACE          reduce using rule 79 (expression -> expression MODULO expression .)
    DEFAULT         reduce using rule 79 (expression -> expression MODULO expression .)
    CASE            reduce using rule 79 (expression -> expression MODULO expression .)
    COLON           reduce using rule 79 (expression -> expression MODULO expression .)
    RBRACKET        reduce using rule 79 (expression -> expression MODULO expression .)
    CLOSED_RANGE    reduce using rule 79 (expression -> expression MODULO expression .)
    HALF_OPEN_RANGE reduce using rule 79 (expression -> expression MODULO expression .)

  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 56 ]
  ! TIMES           [ shift and go to state 57 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULO          [ shift and go to state 59 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 120

    (82) expression -> expression AND expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 82 (expression -> expression AND expression .)
    DOT             reduce using rule 82 (expression -> expression AND expression .)
    AND             reduce using rule 82 (expression -> expression AND expression .)
    OR              reduce using rule 82 (expression -> expression AND expression .)
    QUESTION        reduce using rule 82 (expression -> expression AND expression .)
    NIL_COALESCE    reduce using rule 82 (expression -> expression AND expression .)
    NEWLINE         reduce using rule 82 (expression -> expression AND expression .)
    LET             reduce using rule 82 (expression -> expression AND expression .)
    VAR             reduce using rule 82 (expression -> expression AND expression .)
    IF              reduce using rule 82 (expression -> expression AND expression .)
    GUARD           reduce using rule 82 (expression -> expression AND expression .)
    SWITCH          reduce using rule 82 (expression -> expression AND expression .)
    IDENTIFIER      reduce using rule 82 (expression -> expression AND expression .)
    RETURN          reduce using rule 82 (expression -> expression AND expression .)
    BREAK           reduce using rule 82 (expression -> expression AND expression .)
    CONTINUE        reduce using rule 82 (expression -> expression AND expression .)
    SELF            reduce using rule 82 (expression -> expression AND expression .)
    FOR             reduce using rule 82 (expression -> expression AND expression .)
    WHILE           reduce using rule 82 (expression -> expression AND expression .)
    FUNC            reduce using rule 82 (expression -> expression AND expression .)
    CLASS           reduce using rule 82 (expression -> expression AND expression .)
    LPAREN          reduce using rule 82 (expression -> expression AND expression .)
    NOT             reduce using rule 82 (expression -> expression AND expression .)
    INT_LITERAL     reduce using rule 82 (expression -> expression AND expression .)
    FLOAT_LITERAL   reduce using rule 82 (expression -> expression AND expression .)
    STRING          reduce using rule 82 (expression -> expression AND expression .)
    TRUE            reduce using rule 82 (expression -> expression AND expression .)
    FALSE           reduce using rule 82 (expression -> expression AND expression .)
    NIL             reduce using rule 82 (expression -> expression AND expression .)
    $end            reduce using rule 82 (expression -> expression AND expression .)
    LBRACE          reduce using rule 82 (expression -> expression AND expression .)
    ELSE            reduce using rule 82 (expression -> expression AND expression .)
    RPAREN          reduce using rule 82 (expression -> expression AND expression .)
    COMMA           reduce using rule 82 (expression -> expression AND expression .)
    RBRACE          reduce using rule 82 (expression -> expression AND expression .)
    DEFAULT         reduce using rule 82 (expression -> expression AND expression .)
    CASE            reduce using rule 82 (expression -> expression AND expression .)
    COLON           reduce using rule 82 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 82 (expression -> expression AND expression .)
    CLOSED_RANGE    reduce using rule 82 (expression -> expression AND expression .)
    HALF_OPEN_RANGE reduce using rule 82 (expression -> expression AND expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67

  ! PLUS            [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! NE              [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 82 (expression -> expression AND expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 121

    (83) expression -> expression OR expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 83 (expression -> expression OR expression .)
    DOT             reduce using rule 83 (expression -> expression OR expression .)
    OR              reduce using rule 83 (expression -> expression OR expression .)
    QUESTION        reduce using rule 83 (expression -> expression OR expression .)
    NIL_COALESCE    reduce using rule 83 (expression -> expression OR expression .)
    NEWLINE         reduce using rule 83 (expression -> expression OR expression .)
    LET             reduce using rule 83 (expression -> expression OR expression .)
    VAR             reduce using rule 83 (expression -> expression OR expression .)
    IF              reduce using rule 83 (expression -> expression OR expression .)
    GUARD           reduce using rule 83 (expression -> expression OR expression .)
    SWITCH          reduce using rule 83 (expression -> expression OR expression .)
    IDENTIFIER      reduce using rule 83 (expression -> expression OR expression .)
    RETURN          reduce using rule 83 (expression -> expression OR expression .)
    BREAK           reduce using rule 83 (expression -> expression OR expression .)
    CONTINUE        reduce using rule 83 (expression -> expression OR expression .)
    SELF            reduce using rule 83 (expression -> expression OR expression .)
    FOR             reduce using rule 83 (expression -> expression OR expression .)
    WHILE           reduce using rule 83 (expression -> expression OR expression .)
    FUNC            reduce using rule 83 (expression -> expression OR expression .)
    CLASS           reduce using rule 83 (expression -> expression OR expression .)
    LPAREN          reduce using rule 83 (expression -> expression OR expression .)
    NOT             reduce using rule 83 (expression -> expression OR expression .)
    INT_LITERAL     reduce using rule 83 (expression -> expression OR expression .)
    FLOAT_LITERAL   reduce using rule 83 (expression -> expression OR expression .)
    STRING          reduce using rule 83 (expression -> expression OR expression .)
    TRUE            reduce using rule 83 (expression -> expression OR expression .)
    FALSE           reduce using rule 83 (expression -> expression OR expression .)
    NIL             reduce using rule 83 (expression -> expression OR expression .)
    $end            reduce using rule 83 (expression -> expression OR expression .)
    LBRACE          reduce using rule 83 (expression -> expression OR expression .)
    ELSE            reduce using rule 83 (expression -> expression OR expression .)
    RPAREN          reduce using rule 83 (expression -> expression OR expression .)
    COMMA           reduce using rule 83 (expression -> expression OR expression .)
    RBRACE          reduce using rule 83 (expression -> expression OR expression .)
    DEFAULT         reduce using rule 83 (expression -> expression OR expression .)
    CASE            reduce using rule 83 (expression -> expression OR expression .)
    COLON           reduce using rule 83 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 83 (expression -> expression OR expression .)
    CLOSED_RANGE    reduce using rule 83 (expression -> expression OR expression .)
    HALF_OPEN_RANGE reduce using rule 83 (expression -> expression OR expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67

  ! PLUS            [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! NE              [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 83 (expression -> expression OR expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 61 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 122

    (85) expression -> expression EQ expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 85 (expression -> expression EQ expression .)
    DOT             reduce using rule 85 (expression -> expression EQ expression .)
    AND             reduce using rule 85 (expression -> expression EQ expression .)
    OR              reduce using rule 85 (expression -> expression EQ expression .)
    EQ              reduce using rule 85 (expression -> expression EQ expression .)
    NE              reduce using rule 85 (expression -> expression EQ expression .)
    QUESTION        reduce using rule 85 (expression -> expression EQ expression .)
    NIL_COALESCE    reduce using rule 85 (expression -> expression EQ expression .)
    NEWLINE         reduce using rule 85 (expression -> expression EQ expression .)
    LET             reduce using rule 85 (expression -> expression EQ expression .)
    VAR             reduce using rule 85 (expression -> expression EQ expression .)
    IF              reduce using rule 85 (expression -> expression EQ expression .)
    GUARD           reduce using rule 85 (expression -> expression EQ expression .)
    SWITCH          reduce using rule 85 (expression -> expression EQ expression .)
    IDENTIFIER      reduce using rule 85 (expression -> expression EQ expression .)
    RETURN          reduce using rule 85 (expression -> expression EQ expression .)
    BREAK           reduce using rule 85 (expression -> expression EQ expression .)
    CONTINUE        reduce using rule 85 (expression -> expression EQ expression .)
    SELF            reduce using rule 85 (expression -> expression EQ expression .)
    FOR             reduce using rule 85 (expression -> expression EQ expression .)
    WHILE           reduce using rule 85 (expression -> expression EQ expression .)
    FUNC            reduce using rule 85 (expression -> expression EQ expression .)
    CLASS           reduce using rule 85 (expression -> expression EQ expression .)
    LPAREN          reduce using rule 85 (expression -> expression EQ expression .)
    NOT             reduce using rule 85 (expression -> expression EQ expression .)
    INT_LITERAL     reduce using rule 85 (expression -> expression EQ expression .)
    FLOAT_LITERAL   reduce using rule 85 (expression -> expression EQ expression .)
    STRING          reduce using rule 85 (expression -> expression EQ expression .)
    TRUE            reduce using rule 85 (expression -> expression EQ expression .)
    FALSE           reduce using rule 85 (expression -> expression EQ expression .)
    NIL             reduce using rule 85 (expression -> expression EQ expression .)
    $end            reduce using rule 85 (expression -> expression EQ expression .)
    LBRACE          reduce using rule 85 (expression -> expression EQ expression .)
    ELSE            reduce using rule 85 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 85 (expression -> expression EQ expression .)
    COMMA           reduce using rule 85 (expression -> expression EQ expression .)
    RBRACE          reduce using rule 85 (expression -> expression EQ expression .)
    DEFAULT         reduce using rule 85 (expression -> expression EQ expression .)
    CASE            reduce using rule 85 (expression -> expression EQ expression .)
    COLON           reduce using rule 85 (expression -> expression EQ expression .)
    RBRACKET        reduce using rule 85 (expression -> expression EQ expression .)
    CLOSED_RANGE    reduce using rule 85 (expression -> expression EQ expression .)
    HALF_OPEN_RANGE reduce using rule 85 (expression -> expression EQ expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67

  ! PLUS            [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! MODULO          [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 85 (expression -> expression EQ expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 123

    (86) expression -> expression NE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 86 (expression -> expression NE expression .)
    DOT             reduce using rule 86 (expression -> expression NE expression .)
    AND             reduce using rule 86 (expression -> expression NE expression .)
    OR              reduce using rule 86 (expression -> expression NE expression .)
    EQ              reduce using rule 86 (expression -> expression NE expression .)
    NE              reduce using rule 86 (expression -> expression NE expression .)
    QUESTION        reduce using rule 86 (expression -> expression NE expression .)
    NIL_COALESCE    reduce using rule 86 (expression -> expression NE expression .)
    NEWLINE         reduce using rule 86 (expression -> expression NE expression .)
    LET             reduce using rule 86 (expression -> expression NE expression .)
    VAR             reduce using rule 86 (expression -> expression NE expression .)
    IF              reduce using rule 86 (expression -> expression NE expression .)
    GUARD           reduce using rule 86 (expression -> expression NE expression .)
    SWITCH          reduce using rule 86 (expression -> expression NE expression .)
    IDENTIFIER      reduce using rule 86 (expression -> expression NE expression .)
    RETURN          reduce using rule 86 (expression -> expression NE expression .)
    BREAK           reduce using rule 86 (expression -> expression NE expression .)
    CONTINUE        reduce using rule 86 (expression -> expression NE expression .)
    SELF            reduce using rule 86 (expression -> expression NE expression .)
    FOR             reduce using rule 86 (expression -> expression NE expression .)
    WHILE           reduce using rule 86 (expression -> expression NE expression .)
    FUNC            reduce using rule 86 (expression -> expression NE expression .)
    CLASS           reduce using rule 86 (expression -> expression NE expression .)
    LPAREN          reduce using rule 86 (expression -> expression NE expression .)
    NOT             reduce using rule 86 (expression -> expression NE expression .)
    INT_LITERAL     reduce using rule 86 (expression -> expression NE expression .)
    FLOAT_LITERAL   reduce using rule 86 (expression -> expression NE expression .)
    STRING          reduce using rule 86 (expression -> expression NE expression .)
    TRUE            reduce using rule 86 (expression -> expression NE expression .)
    FALSE           reduce using rule 86 (expression -> expression NE expression .)
    NIL             reduce using rule 86 (expression -> expression NE expression .)
    $end            reduce using rule 86 (expression -> expression NE expression .)
    LBRACE          reduce using rule 86 (expression -> expression NE expression .)
    ELSE            reduce using rule 86 (expression -> expression NE expression .)
    RPAREN          reduce using rule 86 (expression -> expression NE expression .)
    COMMA           reduce using rule 86 (expression -> expression NE expression .)
    RBRACE          reduce using rule 86 (expression -> expression NE expression .)
    DEFAULT         reduce using rule 86 (expression -> expression NE expression .)
    CASE            reduce using rule 86 (expression -> expression NE expression .)
    COLON           reduce using rule 86 (expression -> expression NE expression .)
    RBRACKET        reduce using rule 86 (expression -> expression NE expression .)
    CLOSED_RANGE    reduce using rule 86 (expression -> expression NE expression .)
    HALF_OPEN_RANGE reduce using rule 86 (expression -> expression NE expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67

  ! PLUS            [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! MINUS           [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! TIMES           [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! DIVIDE          [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! MODULO          [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! GT              [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! LT              [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! GE              [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! LE              [ reduce using rule 86 (expression -> expression NE expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 124

    (87) expression -> expression GT expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 87 (expression -> expression GT expression .)
    DOT             reduce using rule 87 (expression -> expression GT expression .)
    AND             reduce using rule 87 (expression -> expression GT expression .)
    OR              reduce using rule 87 (expression -> expression GT expression .)
    EQ              reduce using rule 87 (expression -> expression GT expression .)
    NE              reduce using rule 87 (expression -> expression GT expression .)
    GT              reduce using rule 87 (expression -> expression GT expression .)
    LT              reduce using rule 87 (expression -> expression GT expression .)
    GE              reduce using rule 87 (expression -> expression GT expression .)
    LE              reduce using rule 87 (expression -> expression GT expression .)
    QUESTION        reduce using rule 87 (expression -> expression GT expression .)
    NIL_COALESCE    reduce using rule 87 (expression -> expression GT expression .)
    NEWLINE         reduce using rule 87 (expression -> expression GT expression .)
    LET             reduce using rule 87 (expression -> expression GT expression .)
    VAR             reduce using rule 87 (expression -> expression GT expression .)
    IF              reduce using rule 87 (expression -> expression GT expression .)
    GUARD           reduce using rule 87 (expression -> expression GT expression .)
    SWITCH          reduce using rule 87 (expression -> expression GT expression .)
    IDENTIFIER      reduce using rule 87 (expression -> expression GT expression .)
    RETURN          reduce using rule 87 (expression -> expression GT expression .)
    BREAK           reduce using rule 87 (expression -> expression GT expression .)
    CONTINUE        reduce using rule 87 (expression -> expression GT expression .)
    SELF            reduce using rule 87 (expression -> expression GT expression .)
    FOR             reduce using rule 87 (expression -> expression GT expression .)
    WHILE           reduce using rule 87 (expression -> expression GT expression .)
    FUNC            reduce using rule 87 (expression -> expression GT expression .)
    CLASS           reduce using rule 87 (expression -> expression GT expression .)
    LPAREN          reduce using rule 87 (expression -> expression GT expression .)
    NOT             reduce using rule 87 (expression -> expression GT expression .)
    INT_LITERAL     reduce using rule 87 (expression -> expression GT expression .)
    FLOAT_LITERAL   reduce using rule 87 (expression -> expression GT expression .)
    STRING          reduce using rule 87 (expression -> expression GT expression .)
    TRUE            reduce using rule 87 (expression -> expression GT expression .)
    FALSE           reduce using rule 87 (expression -> expression GT expression .)
    NIL             reduce using rule 87 (expression -> expression GT expression .)
    $end            reduce using rule 87 (expression -> expression GT expression .)
    LBRACE          reduce using rule 87 (expression -> expression GT expression .)
    ELSE            reduce using rule 87 (expression -> expression GT expression .)
    RPAREN          reduce using rule 87 (expression -> expression GT expression .)
    COMMA           reduce using rule 87 (expression -> expression GT expression .)
    RBRACE          reduce using rule 87 (expression -> expression GT expression .)
    DEFAULT         reduce using rule 87 (expression -> expression GT expression .)
    CASE            reduce using rule 87 (expression -> expression GT expression .)
    COLON           reduce using rule 87 (expression -> expression GT expression .)
    RBRACKET        reduce using rule 87 (expression -> expression GT expression .)
    CLOSED_RANGE    reduce using rule 87 (expression -> expression GT expression .)
    HALF_OPEN_RANGE reduce using rule 87 (expression -> expression GT expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59

  ! PLUS            [ reduce using rule 87 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 87 (expression -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 87 (expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 87 (expression -> expression GT expression .) ]
  ! MODULO          [ reduce using rule 87 (expression -> expression GT expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 125

    (88) expression -> expression LT expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 88 (expression -> expression LT expression .)
    DOT             reduce using rule 88 (expression -> expression LT expression .)
    AND             reduce using rule 88 (expression -> expression LT expression .)
    OR              reduce using rule 88 (expression -> expression LT expression .)
    EQ              reduce using rule 88 (expression -> expression LT expression .)
    NE              reduce using rule 88 (expression -> expression LT expression .)
    GT              reduce using rule 88 (expression -> expression LT expression .)
    LT              reduce using rule 88 (expression -> expression LT expression .)
    GE              reduce using rule 88 (expression -> expression LT expression .)
    LE              reduce using rule 88 (expression -> expression LT expression .)
    QUESTION        reduce using rule 88 (expression -> expression LT expression .)
    NIL_COALESCE    reduce using rule 88 (expression -> expression LT expression .)
    NEWLINE         reduce using rule 88 (expression -> expression LT expression .)
    LET             reduce using rule 88 (expression -> expression LT expression .)
    VAR             reduce using rule 88 (expression -> expression LT expression .)
    IF              reduce using rule 88 (expression -> expression LT expression .)
    GUARD           reduce using rule 88 (expression -> expression LT expression .)
    SWITCH          reduce using rule 88 (expression -> expression LT expression .)
    IDENTIFIER      reduce using rule 88 (expression -> expression LT expression .)
    RETURN          reduce using rule 88 (expression -> expression LT expression .)
    BREAK           reduce using rule 88 (expression -> expression LT expression .)
    CONTINUE        reduce using rule 88 (expression -> expression LT expression .)
    SELF            reduce using rule 88 (expression -> expression LT expression .)
    FOR             reduce using rule 88 (expression -> expression LT expression .)
    WHILE           reduce using rule 88 (expression -> expression LT expression .)
    FUNC            reduce using rule 88 (expression -> expression LT expression .)
    CLASS           reduce using rule 88 (expression -> expression LT expression .)
    LPAREN          reduce using rule 88 (expression -> expression LT expression .)
    NOT             reduce using rule 88 (expression -> expression LT expression .)
    INT_LITERAL     reduce using rule 88 (expression -> expression LT expression .)
    FLOAT_LITERAL   reduce using rule 88 (expression -> expression LT expression .)
    STRING          reduce using rule 88 (expression -> expression LT expression .)
    TRUE            reduce using rule 88 (expression -> expression LT expression .)
    FALSE           reduce using rule 88 (expression -> expression LT expression .)
    NIL             reduce using rule 88 (expression -> expression LT expression .)
    $end            reduce using rule 88 (expression -> expression LT expression .)
    LBRACE          reduce using rule 88 (expression -> expression LT expression .)
    ELSE            reduce using rule 88 (expression -> expression LT expression .)
    RPAREN          reduce using rule 88 (expression -> expression LT expression .)
    COMMA           reduce using rule 88 (expression -> expression LT expression .)
    RBRACE          reduce using rule 88 (expression -> expression LT expression .)
    DEFAULT         reduce using rule 88 (expression -> expression LT expression .)
    CASE            reduce using rule 88 (expression -> expression LT expression .)
    COLON           reduce using rule 88 (expression -> expression LT expression .)
    RBRACKET        reduce using rule 88 (expression -> expression LT expression .)
    CLOSED_RANGE    reduce using rule 88 (expression -> expression LT expression .)
    HALF_OPEN_RANGE reduce using rule 88 (expression -> expression LT expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59

  ! PLUS            [ reduce using rule 88 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 88 (expression -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 88 (expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 88 (expression -> expression LT expression .) ]
  ! MODULO          [ reduce using rule 88 (expression -> expression LT expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 126

    (89) expression -> expression GE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 89 (expression -> expression GE expression .)
    DOT             reduce using rule 89 (expression -> expression GE expression .)
    AND             reduce using rule 89 (expression -> expression GE expression .)
    OR              reduce using rule 89 (expression -> expression GE expression .)
    EQ              reduce using rule 89 (expression -> expression GE expression .)
    NE              reduce using rule 89 (expression -> expression GE expression .)
    GT              reduce using rule 89 (expression -> expression GE expression .)
    LT              reduce using rule 89 (expression -> expression GE expression .)
    GE              reduce using rule 89 (expression -> expression GE expression .)
    LE              reduce using rule 89 (expression -> expression GE expression .)
    QUESTION        reduce using rule 89 (expression -> expression GE expression .)
    NIL_COALESCE    reduce using rule 89 (expression -> expression GE expression .)
    NEWLINE         reduce using rule 89 (expression -> expression GE expression .)
    LET             reduce using rule 89 (expression -> expression GE expression .)
    VAR             reduce using rule 89 (expression -> expression GE expression .)
    IF              reduce using rule 89 (expression -> expression GE expression .)
    GUARD           reduce using rule 89 (expression -> expression GE expression .)
    SWITCH          reduce using rule 89 (expression -> expression GE expression .)
    IDENTIFIER      reduce using rule 89 (expression -> expression GE expression .)
    RETURN          reduce using rule 89 (expression -> expression GE expression .)
    BREAK           reduce using rule 89 (expression -> expression GE expression .)
    CONTINUE        reduce using rule 89 (expression -> expression GE expression .)
    SELF            reduce using rule 89 (expression -> expression GE expression .)
    FOR             reduce using rule 89 (expression -> expression GE expression .)
    WHILE           reduce using rule 89 (expression -> expression GE expression .)
    FUNC            reduce using rule 89 (expression -> expression GE expression .)
    CLASS           reduce using rule 89 (expression -> expression GE expression .)
    LPAREN          reduce using rule 89 (expression -> expression GE expression .)
    NOT             reduce using rule 89 (expression -> expression GE expression .)
    INT_LITERAL     reduce using rule 89 (expression -> expression GE expression .)
    FLOAT_LITERAL   reduce using rule 89 (expression -> expression GE expression .)
    STRING          reduce using rule 89 (expression -> expression GE expression .)
    TRUE            reduce using rule 89 (expression -> expression GE expression .)
    FALSE           reduce using rule 89 (expression -> expression GE expression .)
    NIL             reduce using rule 89 (expression -> expression GE expression .)
    $end            reduce using rule 89 (expression -> expression GE expression .)
    LBRACE          reduce using rule 89 (expression -> expression GE expression .)
    ELSE            reduce using rule 89 (expression -> expression GE expression .)
    RPAREN          reduce using rule 89 (expression -> expression GE expression .)
    COMMA           reduce using rule 89 (expression -> expression GE expression .)
    RBRACE          reduce using rule 89 (expression -> expression GE expression .)
    DEFAULT         reduce using rule 89 (expression -> expression GE expression .)
    CASE            reduce using rule 89 (expression -> expression GE expression .)
    COLON           reduce using rule 89 (expression -> expression GE expression .)
    RBRACKET        reduce using rule 89 (expression -> expression GE expression .)
    CLOSED_RANGE    reduce using rule 89 (expression -> expression GE expression .)
    HALF_OPEN_RANGE reduce using rule 89 (expression -> expression GE expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59

  ! PLUS            [ reduce using rule 89 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 89 (expression -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 89 (expression -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 89 (expression -> expression GE expression .) ]
  ! MODULO          [ reduce using rule 89 (expression -> expression GE expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 127

    (90) expression -> expression LE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 90 (expression -> expression LE expression .)
    DOT             reduce using rule 90 (expression -> expression LE expression .)
    AND             reduce using rule 90 (expression -> expression LE expression .)
    OR              reduce using rule 90 (expression -> expression LE expression .)
    EQ              reduce using rule 90 (expression -> expression LE expression .)
    NE              reduce using rule 90 (expression -> expression LE expression .)
    GT              reduce using rule 90 (expression -> expression LE expression .)
    LT              reduce using rule 90 (expression -> expression LE expression .)
    GE              reduce using rule 90 (expression -> expression LE expression .)
    LE              reduce using rule 90 (expression -> expression LE expression .)
    QUESTION        reduce using rule 90 (expression -> expression LE expression .)
    NIL_COALESCE    reduce using rule 90 (expression -> expression LE expression .)
    NEWLINE         reduce using rule 90 (expression -> expression LE expression .)
    LET             reduce using rule 90 (expression -> expression LE expression .)
    VAR             reduce using rule 90 (expression -> expression LE expression .)
    IF              reduce using rule 90 (expression -> expression LE expression .)
    GUARD           reduce using rule 90 (expression -> expression LE expression .)
    SWITCH          reduce using rule 90 (expression -> expression LE expression .)
    IDENTIFIER      reduce using rule 90 (expression -> expression LE expression .)
    RETURN          reduce using rule 90 (expression -> expression LE expression .)
    BREAK           reduce using rule 90 (expression -> expression LE expression .)
    CONTINUE        reduce using rule 90 (expression -> expression LE expression .)
    SELF            reduce using rule 90 (expression -> expression LE expression .)
    FOR             reduce using rule 90 (expression -> expression LE expression .)
    WHILE           reduce using rule 90 (expression -> expression LE expression .)
    FUNC            reduce using rule 90 (expression -> expression LE expression .)
    CLASS           reduce using rule 90 (expression -> expression LE expression .)
    LPAREN          reduce using rule 90 (expression -> expression LE expression .)
    NOT             reduce using rule 90 (expression -> expression LE expression .)
    INT_LITERAL     reduce using rule 90 (expression -> expression LE expression .)
    FLOAT_LITERAL   reduce using rule 90 (expression -> expression LE expression .)
    STRING          reduce using rule 90 (expression -> expression LE expression .)
    TRUE            reduce using rule 90 (expression -> expression LE expression .)
    FALSE           reduce using rule 90 (expression -> expression LE expression .)
    NIL             reduce using rule 90 (expression -> expression LE expression .)
    $end            reduce using rule 90 (expression -> expression LE expression .)
    LBRACE          reduce using rule 90 (expression -> expression LE expression .)
    ELSE            reduce using rule 90 (expression -> expression LE expression .)
    RPAREN          reduce using rule 90 (expression -> expression LE expression .)
    COMMA           reduce using rule 90 (expression -> expression LE expression .)
    RBRACE          reduce using rule 90 (expression -> expression LE expression .)
    DEFAULT         reduce using rule 90 (expression -> expression LE expression .)
    CASE            reduce using rule 90 (expression -> expression LE expression .)
    COLON           reduce using rule 90 (expression -> expression LE expression .)
    RBRACKET        reduce using rule 90 (expression -> expression LE expression .)
    CLOSED_RANGE    reduce using rule 90 (expression -> expression LE expression .)
    HALF_OPEN_RANGE reduce using rule 90 (expression -> expression LE expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59

  ! PLUS            [ reduce using rule 90 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 90 (expression -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 90 (expression -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 90 (expression -> expression LE expression .) ]
  ! MODULO          [ reduce using rule 90 (expression -> expression LE expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! AND             [ shift and go to state 60 ]
  ! OR              [ shift and go to state 61 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 128

    (91) expression -> expression QUESTION expression . COLON expression
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    COLON           shift and go to state 191
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 129

    (92) expression -> expression NIL_COALESCE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    DOT             reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    QUESTION        reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    NIL_COALESCE    reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    NEWLINE         reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    LET             reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    VAR             reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    IF              reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    GUARD           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    SWITCH          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    IDENTIFIER      reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    RETURN          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    BREAK           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    CONTINUE        reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    SELF            reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    FOR             reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    WHILE           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    FUNC            reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    CLASS           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    LPAREN          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    NOT             reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    INT_LITERAL     reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    FLOAT_LITERAL   reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    STRING          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    TRUE            reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    FALSE           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    NIL             reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    $end            reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    LBRACE          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    ELSE            reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    RPAREN          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    COMMA           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    RBRACE          reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    DEFAULT         reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    CASE            reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    COLON           reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    RBRACKET        reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    CLOSED_RANGE    reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    HALF_OPEN_RANGE reduce using rule 92 (expression -> expression NIL_COALESCE expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67

  ! PLUS            [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! MINUS           [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! TIMES           [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! DIVIDE          [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! MODULO          [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! AND             [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! OR              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! EQ              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! NE              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! GT              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! LT              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! GE              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! LE              [ reduce using rule 92 (expression -> expression NIL_COALESCE expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]
  ! QUESTION        [ shift and go to state 68 ]
  ! NIL_COALESCE    [ shift and go to state 69 ]


state 130

    (21) variable_declaration -> VAR IDENTIFIER COLON . type_annotation ASSIGN expression
    (25) variable_declaration -> VAR IDENTIFIER COLON . type_annotation
    (27) variable_declaration -> VAR IDENTIFIER COLON . tuple_type
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LPAREN          shift and go to state 185
    LBRACKET        shift and go to state 186

    type_annotation                shift and go to state 192
    tuple_type                     shift and go to state 193
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184

state 131

    (23) variable_declaration -> VAR IDENTIFIER ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 194

state 132

    (65) assignment -> lvalue ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    LET             reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    VAR             reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    IF              reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    GUARD           reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    SWITCH          reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    IDENTIFIER      reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    RETURN          reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    BREAK           reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    CONTINUE        reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    SELF            reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    FOR             reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    WHILE           reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    FUNC            reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    CLASS           reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    LPAREN          reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    NOT             reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    INT_LITERAL     reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    STRING          reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    TRUE            reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    FALSE           reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    NIL             reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    $end            reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    RBRACE          reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    DEFAULT         reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    CASE            reduce using rule 65 (assignment -> lvalue ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 65 (assignment -> lvalue ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment -> lvalue ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment -> lvalue ASSIGN expression .) ]


state 133

    (66) assignment -> lvalue PLUS_ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    LET             reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    VAR             reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    IF              reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    GUARD           reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    SWITCH          reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    IDENTIFIER      reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    RETURN          reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    BREAK           reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    CONTINUE        reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    SELF            reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    FOR             reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    WHILE           reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    FUNC            reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    CLASS           reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    LPAREN          reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    NOT             reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    INT_LITERAL     reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    STRING          reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    TRUE            reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    FALSE           reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    NIL             reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    $end            reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    RBRACE          reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    DEFAULT         reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    CASE            reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 66 (assignment -> lvalue PLUS_ASSIGN expression .) ]


state 134

    (67) assignment -> lvalue MINUS_ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    LET             reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    VAR             reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    IF              reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    GUARD           reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    SWITCH          reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    IDENTIFIER      reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    RETURN          reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    BREAK           reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    CONTINUE        reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    SELF            reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    FOR             reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    WHILE           reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    FUNC            reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    CLASS           reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    LPAREN          reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    NOT             reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    INT_LITERAL     reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    STRING          reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    TRUE            reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    FALSE           reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    NIL             reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    $end            reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    RBRACE          reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    DEFAULT         reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    CASE            reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 67 (assignment -> lvalue MINUS_ASSIGN expression .) ]


state 135

    (68) assignment -> lvalue TIMES_ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    LET             reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    VAR             reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    IF              reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    GUARD           reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    SWITCH          reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    IDENTIFIER      reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    RETURN          reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    BREAK           reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    CONTINUE        reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    SELF            reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    FOR             reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    WHILE           reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    FUNC            reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    CLASS           reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    LPAREN          reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    NOT             reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    INT_LITERAL     reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    STRING          reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    TRUE            reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    FALSE           reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    NIL             reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    $end            reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    RBRACE          reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    DEFAULT         reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    CASE            reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 68 (assignment -> lvalue TIMES_ASSIGN expression .) ]


state 136

    (69) assignment -> lvalue DIV_ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    LET             reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    VAR             reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    IF              reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    GUARD           reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    SWITCH          reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    IDENTIFIER      reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    RETURN          reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    BREAK           reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    CONTINUE        reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    SELF            reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    FOR             reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    WHILE           reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    FUNC            reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    CLASS           reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    LPAREN          reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    NOT             reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    INT_LITERAL     reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    STRING          reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    TRUE            reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    FALSE           reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    NIL             reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    $end            reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    RBRACE          reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    DEFAULT         reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    CASE            reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 69 (assignment -> lvalue DIV_ASSIGN expression .) ]


state 137

    (70) assignment -> lvalue MOD_ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    LET             reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    VAR             reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    IF              reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    GUARD           reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    SWITCH          reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    IDENTIFIER      reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    RETURN          reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    BREAK           reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    CONTINUE        reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    SELF            reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    FOR             reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    WHILE           reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    FUNC            reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    CLASS           reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    LPAREN          reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    NOT             reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    INT_LITERAL     reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    STRING          reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    TRUE            reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    FALSE           reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    NIL             reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    $end            reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    RBRACE          reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    DEFAULT         reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    CASE            reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 70 (assignment -> lvalue MOD_ASSIGN expression .) ]


state 138

    (73) lvalue -> lvalue DOT IDENTIFIER .

    ASSIGN          reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    PLUS_ASSIGN     reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    MINUS_ASSIGN    reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    TIMES_ASSIGN    reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    DIV_ASSIGN      reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    MOD_ASSIGN      reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    DOT             reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)
    LBRACKET        reduce using rule 73 (lvalue -> lvalue DOT IDENTIFIER .)


state 139

    (74) lvalue -> lvalue LBRACKET expression . RBRACKET
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RBRACKET        shift and go to state 195
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 140

    (104) for_statement -> for_header LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 196
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    for_header                     shift and go to state 24
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 141

    (109) if_statement -> IF expression LBRACE . statement_list RBRACE
    (110) if_statement -> IF expression LBRACE . statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> IF expression LBRACE . statement_list RBRACE else_if_chain
    (112) if_statement -> IF expression LBRACE . statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement_list                 shift and go to state 197
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 142

    (102) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (103) expression -> IDENTIFIER LPAREN . RPAREN
    (145) argument_list -> . argument_list COMMA expression
    (146) argument_list -> . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RPAREN          shift and go to state 199
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    argument_list                  shift and go to state 198
    expression                     shift and go to state 111

state 143

    (101) expression -> SELF DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 200


state 144

    (116) guard_statement -> GUARD expression ELSE . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 201


state 145

    (117) while_statement -> while_header LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 202
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    while_header                   shift and go to state 27
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 146

    (121) switch_statement -> SWITCH expression LBRACE . optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> SWITCH expression LBRACE . optional_newlines case_list default_case optional_newlines RBRACE
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    NEWLINE         reduce using rule 170 (empty -> .)
    CASE            reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 203
    empty                          shift and go to state 204

state 147

    (132) function_declaration -> func_header LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 205
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    func_header                    shift and go to state 29
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    class_header                   shift and go to state 31

state 148

    (58) expression -> LPAREN tuple_elements RPAREN .

    LBRACKET        reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    DOT             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    PLUS            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    MINUS           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    TIMES           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    DIVIDE          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    MODULO          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    AND             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    OR              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    EQ              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    NE              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    GT              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    LT              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    GE              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    LE              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    QUESTION        reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    NIL_COALESCE    reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    NEWLINE         reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    LET             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    VAR             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    IF              reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    GUARD           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    SWITCH          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    IDENTIFIER      reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    RETURN          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    BREAK           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    CONTINUE        reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    SELF            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    FOR             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    WHILE           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    FUNC            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    CLASS           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    LPAREN          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    NOT             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    INT_LITERAL     reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    FLOAT_LITERAL   reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    STRING          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    TRUE            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    FALSE           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    NIL             reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    $end            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    LBRACE          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    ELSE            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    RPAREN          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    COMMA           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    RBRACE          reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    DEFAULT         reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    CASE            reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    COLON           reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    RBRACKET        reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    CLOSED_RANGE    reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)
    HALF_OPEN_RANGE reduce using rule 58 (expression -> LPAREN tuple_elements RPAREN .)


state 149

    (59) tuple_elements -> tuple_elements COMMA . tuple_element
    (61) tuple_element -> . IDENTIFIER COLON expression
    (62) tuple_element -> . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 207
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    SELF            shift and go to state 82

    tuple_element                  shift and go to state 206
    expression                     shift and go to state 208

state 150

    (93) expression -> LPAREN expression RPAREN .

    LBRACKET        reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    QUESTION        reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    NIL_COALESCE    reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    LET             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    VAR             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    GUARD           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    SELF            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    CLASS           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    NOT             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    INT_LITERAL     reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    FLOAT_LITERAL   reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    NIL             reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    CASE            reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    CLOSED_RANGE    reduce using rule 93 (expression -> LPAREN expression RPAREN .)
    HALF_OPEN_RANGE reduce using rule 93 (expression -> LPAREN expression RPAREN .)


state 151

    (61) tuple_element -> IDENTIFIER COLON . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 209

state 152

    (147) class_declaration -> class_header LBRACE class_body . RBRACE
    (149) class_body -> class_body . class_member
    (152) class_member -> . property_declaration
    (153) class_member -> . init_declaration
    (154) class_member -> . method_declaration
    (155) class_member -> . computed_property
    (156) class_member -> . NEWLINE
    (157) property_declaration -> . VAR IDENTIFIER COLON type_annotation
    (158) property_declaration -> . LET IDENTIFIER COLON type_annotation
    (159) property_declaration -> . VAR IDENTIFIER COLON tuple_type
    (160) property_declaration -> . LET IDENTIFIER COLON tuple_type
    (162) init_declaration -> . init_header LBRACE statement_list RBRACE
    (165) method_declaration -> . method_header LBRACE statement_list RBRACE
    (161) computed_property -> . VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
    (163) init_header -> . INIT LPAREN parameter_list RPAREN
    (164) init_header -> . INIT LPAREN RPAREN
    (166) method_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (167) method_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (168) method_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (169) method_header -> . FUNC IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 210
    NEWLINE         shift and go to state 159
    VAR             shift and go to state 160
    LET             shift and go to state 161
    INIT            shift and go to state 164
    FUNC            shift and go to state 165

    class_member                   shift and go to state 211
    property_declaration           shift and go to state 155
    init_declaration               shift and go to state 156
    method_declaration             shift and go to state 157
    computed_property              shift and go to state 158
    init_header                    shift and go to state 162
    method_header                  shift and go to state 163

state 153

    (150) class_body -> class_member .

    RBRACE          reduce using rule 150 (class_body -> class_member .)
    NEWLINE         reduce using rule 150 (class_body -> class_member .)
    VAR             reduce using rule 150 (class_body -> class_member .)
    LET             reduce using rule 150 (class_body -> class_member .)
    INIT            reduce using rule 150 (class_body -> class_member .)
    FUNC            reduce using rule 150 (class_body -> class_member .)


state 154

    (151) class_body -> empty .

    RBRACE          reduce using rule 151 (class_body -> empty .)
    NEWLINE         reduce using rule 151 (class_body -> empty .)
    VAR             reduce using rule 151 (class_body -> empty .)
    LET             reduce using rule 151 (class_body -> empty .)
    INIT            reduce using rule 151 (class_body -> empty .)
    FUNC            reduce using rule 151 (class_body -> empty .)


state 155

    (152) class_member -> property_declaration .

    RBRACE          reduce using rule 152 (class_member -> property_declaration .)
    NEWLINE         reduce using rule 152 (class_member -> property_declaration .)
    VAR             reduce using rule 152 (class_member -> property_declaration .)
    LET             reduce using rule 152 (class_member -> property_declaration .)
    INIT            reduce using rule 152 (class_member -> property_declaration .)
    FUNC            reduce using rule 152 (class_member -> property_declaration .)


state 156

    (153) class_member -> init_declaration .

    RBRACE          reduce using rule 153 (class_member -> init_declaration .)
    NEWLINE         reduce using rule 153 (class_member -> init_declaration .)
    VAR             reduce using rule 153 (class_member -> init_declaration .)
    LET             reduce using rule 153 (class_member -> init_declaration .)
    INIT            reduce using rule 153 (class_member -> init_declaration .)
    FUNC            reduce using rule 153 (class_member -> init_declaration .)


state 157

    (154) class_member -> method_declaration .

    RBRACE          reduce using rule 154 (class_member -> method_declaration .)
    NEWLINE         reduce using rule 154 (class_member -> method_declaration .)
    VAR             reduce using rule 154 (class_member -> method_declaration .)
    LET             reduce using rule 154 (class_member -> method_declaration .)
    INIT            reduce using rule 154 (class_member -> method_declaration .)
    FUNC            reduce using rule 154 (class_member -> method_declaration .)


state 158

    (155) class_member -> computed_property .

    RBRACE          reduce using rule 155 (class_member -> computed_property .)
    NEWLINE         reduce using rule 155 (class_member -> computed_property .)
    VAR             reduce using rule 155 (class_member -> computed_property .)
    LET             reduce using rule 155 (class_member -> computed_property .)
    INIT            reduce using rule 155 (class_member -> computed_property .)
    FUNC            reduce using rule 155 (class_member -> computed_property .)


state 159

    (156) class_member -> NEWLINE .

    RBRACE          reduce using rule 156 (class_member -> NEWLINE .)
    NEWLINE         reduce using rule 156 (class_member -> NEWLINE .)
    VAR             reduce using rule 156 (class_member -> NEWLINE .)
    LET             reduce using rule 156 (class_member -> NEWLINE .)
    INIT            reduce using rule 156 (class_member -> NEWLINE .)
    FUNC            reduce using rule 156 (class_member -> NEWLINE .)


state 160

    (157) property_declaration -> VAR . IDENTIFIER COLON type_annotation
    (159) property_declaration -> VAR . IDENTIFIER COLON tuple_type
    (161) computed_property -> VAR . IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE

    IDENTIFIER      shift and go to state 212


state 161

    (158) property_declaration -> LET . IDENTIFIER COLON type_annotation
    (160) property_declaration -> LET . IDENTIFIER COLON tuple_type

    IDENTIFIER      shift and go to state 213


state 162

    (162) init_declaration -> init_header . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 214


state 163

    (165) method_declaration -> method_header . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 215


state 164

    (163) init_header -> INIT . LPAREN parameter_list RPAREN
    (164) init_header -> INIT . LPAREN RPAREN

    LPAREN          shift and go to state 216


state 165

    (166) method_header -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (167) method_header -> FUNC . IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (168) method_header -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN
    (169) method_header -> FUNC . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 217


state 166

    (72) lvalue -> SELF DOT IDENTIFIER .
    (101) expression -> SELF DOT IDENTIFIER .

  ! reduce/reduce conflict for LBRACKET resolved using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
  ! reduce/reduce conflict for DOT resolved using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    ASSIGN          reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    PLUS_ASSIGN     reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    MINUS_ASSIGN    reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    TIMES_ASSIGN    reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    DIV_ASSIGN      reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    MOD_ASSIGN      reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    DOT             reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    LBRACKET        reduce using rule 72 (lvalue -> SELF DOT IDENTIFIER .)
    PLUS            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    MINUS           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    TIMES           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    DIVIDE          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    MODULO          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    AND             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    OR              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    EQ              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NE              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    GT              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LT              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    GE              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LE              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    QUESTION        reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NIL_COALESCE    reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NEWLINE         reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LET             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    VAR             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    IF              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    GUARD           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    SWITCH          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    RETURN          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    BREAK           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CONTINUE        reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    SELF            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FOR             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    WHILE           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FUNC            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CLASS           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LPAREN          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NOT             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    INT_LITERAL     reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FLOAT_LITERAL   reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    STRING          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    TRUE            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FALSE           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NIL             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    $end            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    RBRACE          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    DEFAULT         reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CASE            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)

  ! LBRACKET        [ reduce using rule 101 (expression -> SELF DOT IDENTIFIER .) ]
  ! DOT             [ reduce using rule 101 (expression -> SELF DOT IDENTIFIER .) ]


state 167

    (42) expression -> LBRACKET array_elements RBRACKET .

    LBRACKET        reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    DOT             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    PLUS            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    MINUS           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    TIMES           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    DIVIDE          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    MODULO          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    AND             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    OR              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    EQ              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    NE              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    GT              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    LT              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    GE              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    LE              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    QUESTION        reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    NIL_COALESCE    reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    NEWLINE         reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    LET             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    VAR             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    IF              reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    GUARD           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    SWITCH          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    IDENTIFIER      reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    RETURN          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    BREAK           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    CONTINUE        reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    SELF            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    FOR             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    WHILE           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    FUNC            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    CLASS           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    LPAREN          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    NOT             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    INT_LITERAL     reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    FLOAT_LITERAL   reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    STRING          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    TRUE            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    FALSE           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    NIL             reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    $end            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    LBRACE          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    ELSE            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    RPAREN          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    COMMA           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    RBRACE          reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    DEFAULT         reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    CASE            reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    COLON           reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    RBRACKET        reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    CLOSED_RANGE    reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)
    HALF_OPEN_RANGE reduce using rule 42 (expression -> LBRACKET array_elements RBRACKET .)


state 168

    (44) array_elements -> array_elements COMMA . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 218

state 169

    (48) expression -> LBRACKET dictionary_pairs RBRACKET .

    LBRACKET        reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    DOT             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    PLUS            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    MINUS           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    TIMES           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    DIVIDE          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    MODULO          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    AND             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    OR              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    EQ              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    NE              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    GT              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    LT              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    GE              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    LE              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    QUESTION        reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    NIL_COALESCE    reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    NEWLINE         reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    LET             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    VAR             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    IF              reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    GUARD           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    SWITCH          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    IDENTIFIER      reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    RETURN          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    BREAK           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    CONTINUE        reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    SELF            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    FOR             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    WHILE           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    FUNC            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    CLASS           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    LPAREN          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    NOT             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    INT_LITERAL     reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    FLOAT_LITERAL   reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    STRING          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    TRUE            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    FALSE           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    NIL             reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    $end            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    LBRACE          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    ELSE            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    RPAREN          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    COMMA           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    RBRACE          reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    DEFAULT         reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    CASE            reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    COLON           reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    RBRACKET        reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    CLOSED_RANGE    reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)
    HALF_OPEN_RANGE reduce using rule 48 (expression -> LBRACKET dictionary_pairs RBRACKET .)


state 170

    (50) dictionary_pairs -> dictionary_pairs COMMA . dictionary_pair
    (52) dictionary_pair -> . expression COLON expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    dictionary_pair                shift and go to state 219
    expression                     shift and go to state 220

state 171

    (49) expression -> LBRACKET COLON RBRACKET .

    LBRACKET        reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    DOT             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    PLUS            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    MINUS           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    TIMES           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    DIVIDE          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    MODULO          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    AND             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    OR              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    EQ              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    NE              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    GT              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    LT              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    GE              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    LE              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    QUESTION        reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    NIL_COALESCE    reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    NEWLINE         reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    LET             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    VAR             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    IF              reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    GUARD           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    SWITCH          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    IDENTIFIER      reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    RETURN          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    BREAK           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    CONTINUE        reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    SELF            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    FOR             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    WHILE           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    FUNC            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    CLASS           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    LPAREN          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    NOT             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    INT_LITERAL     reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    FLOAT_LITERAL   reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    STRING          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    TRUE            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    FALSE           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    NIL             reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    $end            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    LBRACE          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    ELSE            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    RPAREN          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    COMMA           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    RBRACE          reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    DEFAULT         reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    CASE            reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    COLON           reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    RBRACKET        reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    CLOSED_RANGE    reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)
    HALF_OPEN_RANGE reduce using rule 49 (expression -> LBRACKET COLON RBRACKET .)


state 172

    (52) dictionary_pair -> expression COLON . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 221

state 173

    (105) for_header -> FOR IDENTIFIER IN . range_expression
    (106) for_header -> FOR IDENTIFIER IN . expression
    (107) range_expression -> . expression CLOSED_RANGE expression
    (108) range_expression -> . expression HALF_OPEN_RANGE expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    range_expression               shift and go to state 222
    expression                     shift and go to state 223

state 174

    (133) func_header -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN ARROW type_annotation
    (134) func_header -> FUNC IDENTIFIER LPAREN . RPAREN ARROW type_annotation
    (135) func_header -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN
    (136) func_header -> FUNC IDENTIFIER LPAREN . RPAREN
    (137) parameter_list -> . parameter_list COMMA parameter
    (138) parameter_list -> . parameter
    (139) parameter -> . IDENTIFIER COLON type_annotation
    (140) parameter -> . IDENTIFIER COLON type_annotation ASSIGN expression

    RPAREN          shift and go to state 226
    IDENTIFIER      shift and go to state 224

    parameter_list                 shift and go to state 225
    parameter                      shift and go to state 227

state 175

    (36) type_annotation -> IDENTIFIER .

    ASSIGN          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    NEWLINE         reduce using rule 36 (type_annotation -> IDENTIFIER .)
    LET             reduce using rule 36 (type_annotation -> IDENTIFIER .)
    VAR             reduce using rule 36 (type_annotation -> IDENTIFIER .)
    IF              reduce using rule 36 (type_annotation -> IDENTIFIER .)
    GUARD           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    SWITCH          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (type_annotation -> IDENTIFIER .)
    RETURN          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    BREAK           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    CONTINUE        reduce using rule 36 (type_annotation -> IDENTIFIER .)
    SELF            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    FOR             reduce using rule 36 (type_annotation -> IDENTIFIER .)
    WHILE           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    FUNC            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    CLASS           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    LBRACKET        reduce using rule 36 (type_annotation -> IDENTIFIER .)
    LPAREN          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    MINUS           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    PLUS            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    NOT             reduce using rule 36 (type_annotation -> IDENTIFIER .)
    INT_LITERAL     reduce using rule 36 (type_annotation -> IDENTIFIER .)
    FLOAT_LITERAL   reduce using rule 36 (type_annotation -> IDENTIFIER .)
    STRING          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    TRUE            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    FALSE           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    NIL             reduce using rule 36 (type_annotation -> IDENTIFIER .)
    $end            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    RBRACE          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    DEFAULT         reduce using rule 36 (type_annotation -> IDENTIFIER .)
    CASE            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    RBRACKET        reduce using rule 36 (type_annotation -> IDENTIFIER .)
    COLON           reduce using rule 36 (type_annotation -> IDENTIFIER .)
    LBRACE          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    INIT            reduce using rule 36 (type_annotation -> IDENTIFIER .)
    RPAREN          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    COMMA           reduce using rule 36 (type_annotation -> IDENTIFIER .)


state 176

    (20) variable_declaration -> LET IDENTIFIER COLON type_annotation . ASSIGN expression
    (24) variable_declaration -> LET IDENTIFIER COLON type_annotation .

    ASSIGN          shift and go to state 228
    NEWLINE         reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    LET             reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    VAR             reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    IF              reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    GUARD           reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    SWITCH          reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    IDENTIFIER      reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    RETURN          reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    BREAK           reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    CONTINUE        reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    SELF            reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    FOR             reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    WHILE           reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    FUNC            reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    CLASS           reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    LBRACKET        reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    LPAREN          reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    MINUS           reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    PLUS            reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    NOT             reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    INT_LITERAL     reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    FLOAT_LITERAL   reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    STRING          reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    TRUE            reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    FALSE           reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    NIL             reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    $end            reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    RBRACE          reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    DEFAULT         reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)
    CASE            reduce using rule 24 (variable_declaration -> LET IDENTIFIER COLON type_annotation .)


state 177

    (26) variable_declaration -> LET IDENTIFIER COLON tuple_type .
    (35) type_annotation -> tuple_type .

  ! reduce/reduce conflict for NEWLINE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for LET resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for VAR resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for IF resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for GUARD resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for SWITCH resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for RETURN resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for BREAK resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for SELF resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FOR resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for WHILE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FUNC resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for CLASS resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for LPAREN resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for PLUS resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for NOT resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FLOAT_LITERAL resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for STRING resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for TRUE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FALSE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for NIL resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for $end resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for RBRACE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for CASE resolved using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    NEWLINE         reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    LET             reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    VAR             reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    IF              reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    GUARD           reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    SWITCH          reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    IDENTIFIER      reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    RETURN          reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    BREAK           reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    CONTINUE        reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    SELF            reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    FOR             reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    WHILE           reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    FUNC            reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    CLASS           reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    LBRACKET        reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    LPAREN          reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    MINUS           reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    PLUS            reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    NOT             reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    INT_LITERAL     reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    FLOAT_LITERAL   reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    STRING          reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    TRUE            reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    FALSE           reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    NIL             reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    $end            reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    RBRACE          reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    DEFAULT         reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    CASE            reduce using rule 26 (variable_declaration -> LET IDENTIFIER COLON tuple_type .)
    ASSIGN          reduce using rule 35 (type_annotation -> tuple_type .)

  ! NEWLINE         [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! LET             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! VAR             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! IF              [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! GUARD           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! SWITCH          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! IDENTIFIER      [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! RETURN          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! BREAK           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! CONTINUE        [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! SELF            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FOR             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! WHILE           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FUNC            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! CLASS           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! LBRACKET        [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! LPAREN          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! MINUS           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! PLUS            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! NOT             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! INT_LITERAL     [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FLOAT_LITERAL   [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! STRING          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! TRUE            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FALSE           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! NIL             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! $end            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! RBRACE          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! DEFAULT         [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! CASE            [ reduce using rule 35 (type_annotation -> tuple_type .) ]


state 178

    (28) type_annotation -> TYPE_INT .
    (37) optional_type -> TYPE_INT . QUESTION

    ASSIGN          reduce using rule 28 (type_annotation -> TYPE_INT .)
    NEWLINE         reduce using rule 28 (type_annotation -> TYPE_INT .)
    LET             reduce using rule 28 (type_annotation -> TYPE_INT .)
    VAR             reduce using rule 28 (type_annotation -> TYPE_INT .)
    IF              reduce using rule 28 (type_annotation -> TYPE_INT .)
    GUARD           reduce using rule 28 (type_annotation -> TYPE_INT .)
    SWITCH          reduce using rule 28 (type_annotation -> TYPE_INT .)
    IDENTIFIER      reduce using rule 28 (type_annotation -> TYPE_INT .)
    RETURN          reduce using rule 28 (type_annotation -> TYPE_INT .)
    BREAK           reduce using rule 28 (type_annotation -> TYPE_INT .)
    CONTINUE        reduce using rule 28 (type_annotation -> TYPE_INT .)
    SELF            reduce using rule 28 (type_annotation -> TYPE_INT .)
    FOR             reduce using rule 28 (type_annotation -> TYPE_INT .)
    WHILE           reduce using rule 28 (type_annotation -> TYPE_INT .)
    FUNC            reduce using rule 28 (type_annotation -> TYPE_INT .)
    CLASS           reduce using rule 28 (type_annotation -> TYPE_INT .)
    LBRACKET        reduce using rule 28 (type_annotation -> TYPE_INT .)
    LPAREN          reduce using rule 28 (type_annotation -> TYPE_INT .)
    MINUS           reduce using rule 28 (type_annotation -> TYPE_INT .)
    PLUS            reduce using rule 28 (type_annotation -> TYPE_INT .)
    NOT             reduce using rule 28 (type_annotation -> TYPE_INT .)
    INT_LITERAL     reduce using rule 28 (type_annotation -> TYPE_INT .)
    FLOAT_LITERAL   reduce using rule 28 (type_annotation -> TYPE_INT .)
    STRING          reduce using rule 28 (type_annotation -> TYPE_INT .)
    TRUE            reduce using rule 28 (type_annotation -> TYPE_INT .)
    FALSE           reduce using rule 28 (type_annotation -> TYPE_INT .)
    NIL             reduce using rule 28 (type_annotation -> TYPE_INT .)
    $end            reduce using rule 28 (type_annotation -> TYPE_INT .)
    RBRACE          reduce using rule 28 (type_annotation -> TYPE_INT .)
    DEFAULT         reduce using rule 28 (type_annotation -> TYPE_INT .)
    CASE            reduce using rule 28 (type_annotation -> TYPE_INT .)
    RPAREN          reduce using rule 28 (type_annotation -> TYPE_INT .)
    COMMA           reduce using rule 28 (type_annotation -> TYPE_INT .)
    RBRACKET        reduce using rule 28 (type_annotation -> TYPE_INT .)
    COLON           reduce using rule 28 (type_annotation -> TYPE_INT .)
    LBRACE          reduce using rule 28 (type_annotation -> TYPE_INT .)
    INIT            reduce using rule 28 (type_annotation -> TYPE_INT .)
    QUESTION        shift and go to state 229


state 179

    (29) type_annotation -> TYPE_DOUBLE .
    (38) optional_type -> TYPE_DOUBLE . QUESTION

    ASSIGN          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    NEWLINE         reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    LET             reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    VAR             reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    IF              reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    GUARD           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    SWITCH          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    IDENTIFIER      reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    RETURN          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    BREAK           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    CONTINUE        reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    SELF            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    FOR             reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    WHILE           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    FUNC            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    CLASS           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    LBRACKET        reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    LPAREN          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    MINUS           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    PLUS            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    NOT             reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    INT_LITERAL     reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    FLOAT_LITERAL   reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    STRING          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    TRUE            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    FALSE           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    NIL             reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    $end            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    RBRACE          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    DEFAULT         reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    CASE            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    RPAREN          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    COMMA           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    RBRACKET        reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    COLON           reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    LBRACE          reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    INIT            reduce using rule 29 (type_annotation -> TYPE_DOUBLE .)
    QUESTION        shift and go to state 230


state 180

    (30) type_annotation -> TYPE_BOOL .
    (39) optional_type -> TYPE_BOOL . QUESTION

    ASSIGN          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    NEWLINE         reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    LET             reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    VAR             reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    IF              reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    GUARD           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    SWITCH          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    IDENTIFIER      reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    RETURN          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    BREAK           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    CONTINUE        reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    SELF            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    FOR             reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    WHILE           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    FUNC            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    CLASS           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    LBRACKET        reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    LPAREN          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    MINUS           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    PLUS            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    NOT             reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    INT_LITERAL     reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    FLOAT_LITERAL   reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    STRING          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    TRUE            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    FALSE           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    NIL             reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    $end            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    RBRACE          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    DEFAULT         reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    CASE            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    RPAREN          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    COMMA           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    RBRACKET        reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    COLON           reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    LBRACE          reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    INIT            reduce using rule 30 (type_annotation -> TYPE_BOOL .)
    QUESTION        shift and go to state 231


state 181

    (31) type_annotation -> TYPE_STRING .
    (40) optional_type -> TYPE_STRING . QUESTION

    ASSIGN          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    NEWLINE         reduce using rule 31 (type_annotation -> TYPE_STRING .)
    LET             reduce using rule 31 (type_annotation -> TYPE_STRING .)
    VAR             reduce using rule 31 (type_annotation -> TYPE_STRING .)
    IF              reduce using rule 31 (type_annotation -> TYPE_STRING .)
    GUARD           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    SWITCH          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    IDENTIFIER      reduce using rule 31 (type_annotation -> TYPE_STRING .)
    RETURN          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    BREAK           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    CONTINUE        reduce using rule 31 (type_annotation -> TYPE_STRING .)
    SELF            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    FOR             reduce using rule 31 (type_annotation -> TYPE_STRING .)
    WHILE           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    FUNC            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    CLASS           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    LBRACKET        reduce using rule 31 (type_annotation -> TYPE_STRING .)
    LPAREN          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    MINUS           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    PLUS            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    NOT             reduce using rule 31 (type_annotation -> TYPE_STRING .)
    INT_LITERAL     reduce using rule 31 (type_annotation -> TYPE_STRING .)
    FLOAT_LITERAL   reduce using rule 31 (type_annotation -> TYPE_STRING .)
    STRING          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    TRUE            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    FALSE           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    NIL             reduce using rule 31 (type_annotation -> TYPE_STRING .)
    $end            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    RBRACE          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    DEFAULT         reduce using rule 31 (type_annotation -> TYPE_STRING .)
    CASE            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    RPAREN          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    COMMA           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    RBRACKET        reduce using rule 31 (type_annotation -> TYPE_STRING .)
    COLON           reduce using rule 31 (type_annotation -> TYPE_STRING .)
    LBRACE          reduce using rule 31 (type_annotation -> TYPE_STRING .)
    INIT            reduce using rule 31 (type_annotation -> TYPE_STRING .)
    QUESTION        shift and go to state 232


state 182

    (32) type_annotation -> array_type .

    ASSIGN          reduce using rule 32 (type_annotation -> array_type .)
    NEWLINE         reduce using rule 32 (type_annotation -> array_type .)
    LET             reduce using rule 32 (type_annotation -> array_type .)
    VAR             reduce using rule 32 (type_annotation -> array_type .)
    IF              reduce using rule 32 (type_annotation -> array_type .)
    GUARD           reduce using rule 32 (type_annotation -> array_type .)
    SWITCH          reduce using rule 32 (type_annotation -> array_type .)
    IDENTIFIER      reduce using rule 32 (type_annotation -> array_type .)
    RETURN          reduce using rule 32 (type_annotation -> array_type .)
    BREAK           reduce using rule 32 (type_annotation -> array_type .)
    CONTINUE        reduce using rule 32 (type_annotation -> array_type .)
    SELF            reduce using rule 32 (type_annotation -> array_type .)
    FOR             reduce using rule 32 (type_annotation -> array_type .)
    WHILE           reduce using rule 32 (type_annotation -> array_type .)
    FUNC            reduce using rule 32 (type_annotation -> array_type .)
    CLASS           reduce using rule 32 (type_annotation -> array_type .)
    LBRACKET        reduce using rule 32 (type_annotation -> array_type .)
    LPAREN          reduce using rule 32 (type_annotation -> array_type .)
    MINUS           reduce using rule 32 (type_annotation -> array_type .)
    PLUS            reduce using rule 32 (type_annotation -> array_type .)
    NOT             reduce using rule 32 (type_annotation -> array_type .)
    INT_LITERAL     reduce using rule 32 (type_annotation -> array_type .)
    FLOAT_LITERAL   reduce using rule 32 (type_annotation -> array_type .)
    STRING          reduce using rule 32 (type_annotation -> array_type .)
    TRUE            reduce using rule 32 (type_annotation -> array_type .)
    FALSE           reduce using rule 32 (type_annotation -> array_type .)
    NIL             reduce using rule 32 (type_annotation -> array_type .)
    $end            reduce using rule 32 (type_annotation -> array_type .)
    RBRACE          reduce using rule 32 (type_annotation -> array_type .)
    DEFAULT         reduce using rule 32 (type_annotation -> array_type .)
    CASE            reduce using rule 32 (type_annotation -> array_type .)
    RPAREN          reduce using rule 32 (type_annotation -> array_type .)
    COMMA           reduce using rule 32 (type_annotation -> array_type .)
    RBRACKET        reduce using rule 32 (type_annotation -> array_type .)
    COLON           reduce using rule 32 (type_annotation -> array_type .)
    LBRACE          reduce using rule 32 (type_annotation -> array_type .)
    INIT            reduce using rule 32 (type_annotation -> array_type .)


state 183

    (33) type_annotation -> dictionary_type .

    ASSIGN          reduce using rule 33 (type_annotation -> dictionary_type .)
    NEWLINE         reduce using rule 33 (type_annotation -> dictionary_type .)
    LET             reduce using rule 33 (type_annotation -> dictionary_type .)
    VAR             reduce using rule 33 (type_annotation -> dictionary_type .)
    IF              reduce using rule 33 (type_annotation -> dictionary_type .)
    GUARD           reduce using rule 33 (type_annotation -> dictionary_type .)
    SWITCH          reduce using rule 33 (type_annotation -> dictionary_type .)
    IDENTIFIER      reduce using rule 33 (type_annotation -> dictionary_type .)
    RETURN          reduce using rule 33 (type_annotation -> dictionary_type .)
    BREAK           reduce using rule 33 (type_annotation -> dictionary_type .)
    CONTINUE        reduce using rule 33 (type_annotation -> dictionary_type .)
    SELF            reduce using rule 33 (type_annotation -> dictionary_type .)
    FOR             reduce using rule 33 (type_annotation -> dictionary_type .)
    WHILE           reduce using rule 33 (type_annotation -> dictionary_type .)
    FUNC            reduce using rule 33 (type_annotation -> dictionary_type .)
    CLASS           reduce using rule 33 (type_annotation -> dictionary_type .)
    LBRACKET        reduce using rule 33 (type_annotation -> dictionary_type .)
    LPAREN          reduce using rule 33 (type_annotation -> dictionary_type .)
    MINUS           reduce using rule 33 (type_annotation -> dictionary_type .)
    PLUS            reduce using rule 33 (type_annotation -> dictionary_type .)
    NOT             reduce using rule 33 (type_annotation -> dictionary_type .)
    INT_LITERAL     reduce using rule 33 (type_annotation -> dictionary_type .)
    FLOAT_LITERAL   reduce using rule 33 (type_annotation -> dictionary_type .)
    STRING          reduce using rule 33 (type_annotation -> dictionary_type .)
    TRUE            reduce using rule 33 (type_annotation -> dictionary_type .)
    FALSE           reduce using rule 33 (type_annotation -> dictionary_type .)
    NIL             reduce using rule 33 (type_annotation -> dictionary_type .)
    $end            reduce using rule 33 (type_annotation -> dictionary_type .)
    RBRACE          reduce using rule 33 (type_annotation -> dictionary_type .)
    DEFAULT         reduce using rule 33 (type_annotation -> dictionary_type .)
    CASE            reduce using rule 33 (type_annotation -> dictionary_type .)
    RPAREN          reduce using rule 33 (type_annotation -> dictionary_type .)
    COMMA           reduce using rule 33 (type_annotation -> dictionary_type .)
    RBRACKET        reduce using rule 33 (type_annotation -> dictionary_type .)
    COLON           reduce using rule 33 (type_annotation -> dictionary_type .)
    LBRACE          reduce using rule 33 (type_annotation -> dictionary_type .)
    INIT            reduce using rule 33 (type_annotation -> dictionary_type .)


state 184

    (34) type_annotation -> optional_type .

    ASSIGN          reduce using rule 34 (type_annotation -> optional_type .)
    NEWLINE         reduce using rule 34 (type_annotation -> optional_type .)
    LET             reduce using rule 34 (type_annotation -> optional_type .)
    VAR             reduce using rule 34 (type_annotation -> optional_type .)
    IF              reduce using rule 34 (type_annotation -> optional_type .)
    GUARD           reduce using rule 34 (type_annotation -> optional_type .)
    SWITCH          reduce using rule 34 (type_annotation -> optional_type .)
    IDENTIFIER      reduce using rule 34 (type_annotation -> optional_type .)
    RETURN          reduce using rule 34 (type_annotation -> optional_type .)
    BREAK           reduce using rule 34 (type_annotation -> optional_type .)
    CONTINUE        reduce using rule 34 (type_annotation -> optional_type .)
    SELF            reduce using rule 34 (type_annotation -> optional_type .)
    FOR             reduce using rule 34 (type_annotation -> optional_type .)
    WHILE           reduce using rule 34 (type_annotation -> optional_type .)
    FUNC            reduce using rule 34 (type_annotation -> optional_type .)
    CLASS           reduce using rule 34 (type_annotation -> optional_type .)
    LBRACKET        reduce using rule 34 (type_annotation -> optional_type .)
    LPAREN          reduce using rule 34 (type_annotation -> optional_type .)
    MINUS           reduce using rule 34 (type_annotation -> optional_type .)
    PLUS            reduce using rule 34 (type_annotation -> optional_type .)
    NOT             reduce using rule 34 (type_annotation -> optional_type .)
    INT_LITERAL     reduce using rule 34 (type_annotation -> optional_type .)
    FLOAT_LITERAL   reduce using rule 34 (type_annotation -> optional_type .)
    STRING          reduce using rule 34 (type_annotation -> optional_type .)
    TRUE            reduce using rule 34 (type_annotation -> optional_type .)
    FALSE           reduce using rule 34 (type_annotation -> optional_type .)
    NIL             reduce using rule 34 (type_annotation -> optional_type .)
    $end            reduce using rule 34 (type_annotation -> optional_type .)
    RBRACE          reduce using rule 34 (type_annotation -> optional_type .)
    DEFAULT         reduce using rule 34 (type_annotation -> optional_type .)
    CASE            reduce using rule 34 (type_annotation -> optional_type .)
    RPAREN          reduce using rule 34 (type_annotation -> optional_type .)
    COMMA           reduce using rule 34 (type_annotation -> optional_type .)
    RBRACKET        reduce using rule 34 (type_annotation -> optional_type .)
    COLON           reduce using rule 34 (type_annotation -> optional_type .)
    LBRACE          reduce using rule 34 (type_annotation -> optional_type .)
    INIT            reduce using rule 34 (type_annotation -> optional_type .)


state 185

    (53) tuple_type -> LPAREN . tuple_type_elements RPAREN
    (54) tuple_type_elements -> . tuple_type_elements COMMA tuple_type_element
    (55) tuple_type_elements -> . tuple_type_element
    (56) tuple_type_element -> . IDENTIFIER COLON type_annotation
    (57) tuple_type_element -> . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    IDENTIFIER      shift and go to state 235
    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    tuple_type_elements            shift and go to state 233
    tuple_type_element             shift and go to state 234
    type_annotation                shift and go to state 236
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 186

    (41) array_type -> LBRACKET . type_annotation RBRACKET
    (47) dictionary_type -> LBRACKET . type_annotation COLON type_annotation RBRACKET
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 238
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 187

    (22) variable_declaration -> LET IDENTIFIER ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    LET             reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    GUARD           reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    SELF            reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    CLASS           reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    NOT             reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    INT_LITERAL     reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    NIL             reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 22 (variable_declaration -> LET IDENTIFIER ASSIGN expression .) ]


state 188

    (143) function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .
    (102) expression -> IDENTIFIER LPAREN argument_list RPAREN .

  ! reduce/reduce conflict for LBRACKET resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for PLUS resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for MINUS resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for LET resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for VAR resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for GUARD resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for SELF resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for WHILE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for CLASS resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for LPAREN resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for NOT resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for FLOAT_LITERAL resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for STRING resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for TRUE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for FALSE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for NIL resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DOT             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULO          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NE              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    QUESTION        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NIL_COALESCE    reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEWLINE         reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LET             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GUARD           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SELF            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CLASS           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NOT             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT_LITERAL     reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT_LITERAL   reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NIL             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)

  ! NEWLINE         [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! LET             [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! VAR             [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! IF              [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! GUARD           [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! SWITCH          [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! RETURN          [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! BREAK           [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! CONTINUE        [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! SELF            [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! FOR             [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! WHILE           [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! FUNC            [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! CLASS           [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! LBRACKET        [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! LPAREN          [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! MINUS           [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! PLUS            [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! NOT             [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! INT_LITERAL     [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! FLOAT_LITERAL   [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! STRING          [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! TRUE            [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! FALSE           [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! NIL             [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! $end            [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! RBRACE          [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! DEFAULT         [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]
  ! CASE            [ reduce using rule 143 (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN .) ]


state 189

    (145) argument_list -> argument_list COMMA . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 239

state 190

    (46) expression -> expression LBRACKET expression RBRACKET .

    LBRACKET        reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    DOT             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    MODULO          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    AND             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    OR              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    EQ              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    NE              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    GT              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    LT              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    GE              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    LE              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    QUESTION        reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    NIL_COALESCE    reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    NEWLINE         reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    LET             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    VAR             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    IF              reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    GUARD           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    SWITCH          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    IDENTIFIER      reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    RETURN          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    BREAK           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    CONTINUE        reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    SELF            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    FOR             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    WHILE           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    FUNC            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    CLASS           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    NOT             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    INT_LITERAL     reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    FLOAT_LITERAL   reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    STRING          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    TRUE            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    FALSE           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    NIL             reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    $end            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    DEFAULT         reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    CASE            reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    COLON           reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    CLOSED_RANGE    reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)
    HALF_OPEN_RANGE reduce using rule 46 (expression -> expression LBRACKET expression RBRACKET .)


state 191

    (91) expression -> expression QUESTION expression COLON . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 240

state 192

    (21) variable_declaration -> VAR IDENTIFIER COLON type_annotation . ASSIGN expression
    (25) variable_declaration -> VAR IDENTIFIER COLON type_annotation .

    ASSIGN          shift and go to state 241
    NEWLINE         reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    LET             reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    VAR             reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    IF              reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    GUARD           reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    SWITCH          reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    IDENTIFIER      reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    RETURN          reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    BREAK           reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    CONTINUE        reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    SELF            reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    FOR             reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    WHILE           reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    FUNC            reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    CLASS           reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    LBRACKET        reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    LPAREN          reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    MINUS           reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    PLUS            reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    NOT             reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    INT_LITERAL     reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    FLOAT_LITERAL   reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    STRING          reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    TRUE            reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    FALSE           reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    NIL             reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    $end            reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    RBRACE          reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    DEFAULT         reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)
    CASE            reduce using rule 25 (variable_declaration -> VAR IDENTIFIER COLON type_annotation .)


state 193

    (27) variable_declaration -> VAR IDENTIFIER COLON tuple_type .
    (35) type_annotation -> tuple_type .

  ! reduce/reduce conflict for NEWLINE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for LET resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for VAR resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for IF resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for GUARD resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for SWITCH resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for RETURN resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for BREAK resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for SELF resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FOR resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for WHILE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FUNC resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for CLASS resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FLOAT_LITERAL resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for STRING resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for TRUE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for FALSE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for NIL resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for $end resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for RBRACE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
  ! reduce/reduce conflict for CASE resolved using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    NEWLINE         reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    LET             reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    VAR             reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    IF              reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    GUARD           reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    SWITCH          reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    IDENTIFIER      reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    RETURN          reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    BREAK           reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    CONTINUE        reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    SELF            reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    FOR             reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    WHILE           reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    FUNC            reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    CLASS           reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    LBRACKET        reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    LPAREN          reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    MINUS           reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    PLUS            reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    NOT             reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    INT_LITERAL     reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    FLOAT_LITERAL   reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    STRING          reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    TRUE            reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    FALSE           reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    NIL             reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    $end            reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    RBRACE          reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    DEFAULT         reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    CASE            reduce using rule 27 (variable_declaration -> VAR IDENTIFIER COLON tuple_type .)
    ASSIGN          reduce using rule 35 (type_annotation -> tuple_type .)

  ! NEWLINE         [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! LET             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! VAR             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! IF              [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! GUARD           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! SWITCH          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! IDENTIFIER      [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! RETURN          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! BREAK           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! CONTINUE        [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! SELF            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FOR             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! WHILE           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FUNC            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! CLASS           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! LBRACKET        [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! LPAREN          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! MINUS           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! PLUS            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! NOT             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! INT_LITERAL     [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FLOAT_LITERAL   [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! STRING          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! TRUE            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! FALSE           [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! NIL             [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! $end            [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! RBRACE          [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! DEFAULT         [ reduce using rule 35 (type_annotation -> tuple_type .) ]
  ! CASE            [ reduce using rule 35 (type_annotation -> tuple_type .) ]


state 194

    (23) variable_declaration -> VAR IDENTIFIER ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LET             reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    GUARD           reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    SELF            reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CLASS           reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    NOT             reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    INT_LITERAL     reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    NIL             reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 23 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]


state 195

    (74) lvalue -> lvalue LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    PLUS_ASSIGN     reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    MINUS_ASSIGN    reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    TIMES_ASSIGN    reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    DIV_ASSIGN      reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    MOD_ASSIGN      reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    DOT             reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 74 (lvalue -> lvalue LBRACKET expression RBRACKET .)


state 196

    (104) for_statement -> for_header LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    LET             reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    VAR             reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    IF              reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    SELF            reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    FOR             reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    NOT             reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    STRING          reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    NIL             reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    $end            reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)
    CASE            reduce using rule 104 (for_statement -> for_header LBRACE statement_list RBRACE .)


state 197

    (109) if_statement -> IF expression LBRACE statement_list . RBRACE
    (110) if_statement -> IF expression LBRACE statement_list . RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> IF expression LBRACE statement_list . RBRACE else_if_chain
    (112) if_statement -> IF expression LBRACE statement_list . RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 242
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 198

    (102) expression -> IDENTIFIER LPAREN argument_list . RPAREN
    (145) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 243
    COMMA           shift and go to state 189


state 199

    (103) expression -> IDENTIFIER LPAREN RPAREN .

    LBRACE          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LBRACKET        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    MODULO          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NE              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    QUESTION        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NIL_COALESCE    reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LET             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    GUARD           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    SWITCH          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CONTINUE        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    SELF            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FUNC            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CLASS           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NOT             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    INT_LITERAL     reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FLOAT_LITERAL   reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    STRING          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    NIL             reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    DEFAULT         reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CASE            reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    COLON           reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    CLOSED_RANGE    reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)
    HALF_OPEN_RANGE reduce using rule 103 (expression -> IDENTIFIER LPAREN RPAREN .)


state 200

    (101) expression -> SELF DOT IDENTIFIER .

    LBRACE          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LBRACKET        reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    DOT             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    PLUS            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    MINUS           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    TIMES           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    DIVIDE          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    MODULO          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    AND             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    OR              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    EQ              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NE              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    GT              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LT              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    GE              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LE              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    QUESTION        reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NIL_COALESCE    reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    ELSE            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    RPAREN          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    COMMA           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NEWLINE         reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LET             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    VAR             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    IF              reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    GUARD           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    SWITCH          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    RETURN          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    BREAK           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CONTINUE        reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    SELF            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FOR             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    WHILE           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FUNC            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CLASS           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    LPAREN          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NOT             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    INT_LITERAL     reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FLOAT_LITERAL   reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    STRING          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    TRUE            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    FALSE           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    NIL             reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    $end            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    RBRACE          reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    DEFAULT         reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CASE            reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    COLON           reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    RBRACKET        reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    CLOSED_RANGE    reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)
    HALF_OPEN_RANGE reduce using rule 101 (expression -> SELF DOT IDENTIFIER .)


state 201

    (116) guard_statement -> GUARD expression ELSE LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement_list                 shift and go to state 244
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 202

    (117) while_statement -> while_header LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    LET             reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    VAR             reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    IF              reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    SELF            reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    FOR             reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    NOT             reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    STRING          reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    NIL             reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    $end            reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)
    CASE            reduce using rule 117 (while_statement -> while_header LBRACE statement_list RBRACE .)


state 203

    (121) switch_statement -> SWITCH expression LBRACE optional_newlines . case_list optional_newlines RBRACE
    (122) switch_statement -> SWITCH expression LBRACE optional_newlines . case_list default_case optional_newlines RBRACE
    (130) optional_newlines -> optional_newlines . NEWLINE
    (123) case_list -> . case_list optional_newlines case_clause
    (124) case_list -> . optional_newlines case_clause
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 247
    CASE            reduce using rule 170 (empty -> .)

  ! NEWLINE         [ reduce using rule 170 (empty -> .) ]

    optional_newlines              shift and go to state 245
    case_list                      shift and go to state 246
    empty                          shift and go to state 204

state 204

    (131) optional_newlines -> empty .

    NEWLINE         reduce using rule 131 (optional_newlines -> empty .)
    CASE            reduce using rule 131 (optional_newlines -> empty .)
    RBRACE          reduce using rule 131 (optional_newlines -> empty .)
    LET             reduce using rule 131 (optional_newlines -> empty .)
    VAR             reduce using rule 131 (optional_newlines -> empty .)
    IF              reduce using rule 131 (optional_newlines -> empty .)
    GUARD           reduce using rule 131 (optional_newlines -> empty .)
    SWITCH          reduce using rule 131 (optional_newlines -> empty .)
    IDENTIFIER      reduce using rule 131 (optional_newlines -> empty .)
    RETURN          reduce using rule 131 (optional_newlines -> empty .)
    BREAK           reduce using rule 131 (optional_newlines -> empty .)
    CONTINUE        reduce using rule 131 (optional_newlines -> empty .)
    SELF            reduce using rule 131 (optional_newlines -> empty .)
    FOR             reduce using rule 131 (optional_newlines -> empty .)
    WHILE           reduce using rule 131 (optional_newlines -> empty .)
    FUNC            reduce using rule 131 (optional_newlines -> empty .)
    CLASS           reduce using rule 131 (optional_newlines -> empty .)
    LBRACKET        reduce using rule 131 (optional_newlines -> empty .)
    LPAREN          reduce using rule 131 (optional_newlines -> empty .)
    MINUS           reduce using rule 131 (optional_newlines -> empty .)
    PLUS            reduce using rule 131 (optional_newlines -> empty .)
    NOT             reduce using rule 131 (optional_newlines -> empty .)
    INT_LITERAL     reduce using rule 131 (optional_newlines -> empty .)
    FLOAT_LITERAL   reduce using rule 131 (optional_newlines -> empty .)
    STRING          reduce using rule 131 (optional_newlines -> empty .)
    TRUE            reduce using rule 131 (optional_newlines -> empty .)
    FALSE           reduce using rule 131 (optional_newlines -> empty .)
    NIL             reduce using rule 131 (optional_newlines -> empty .)
    GET             reduce using rule 131 (optional_newlines -> empty .)


state 205

    (132) function_declaration -> func_header LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    LET             reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    VAR             reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    IF              reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    SELF            reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    FOR             reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    NOT             reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    STRING          reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    NIL             reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    $end            reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)
    CASE            reduce using rule 132 (function_declaration -> func_header LBRACE statement_list RBRACE .)


state 206

    (59) tuple_elements -> tuple_elements COMMA tuple_element .

    RPAREN          reduce using rule 59 (tuple_elements -> tuple_elements COMMA tuple_element .)
    COMMA           reduce using rule 59 (tuple_elements -> tuple_elements COMMA tuple_element .)


state 207

    (61) tuple_element -> IDENTIFIER . COLON expression
    (100) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (103) expression -> IDENTIFIER . LPAREN RPAREN

    COLON           shift and go to state 151
    LBRACKET        reduce using rule 100 (expression -> IDENTIFIER .)
    DOT             reduce using rule 100 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 100 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 100 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 100 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (expression -> IDENTIFIER .)
    MODULO          reduce using rule 100 (expression -> IDENTIFIER .)
    AND             reduce using rule 100 (expression -> IDENTIFIER .)
    OR              reduce using rule 100 (expression -> IDENTIFIER .)
    EQ              reduce using rule 100 (expression -> IDENTIFIER .)
    NE              reduce using rule 100 (expression -> IDENTIFIER .)
    GT              reduce using rule 100 (expression -> IDENTIFIER .)
    LT              reduce using rule 100 (expression -> IDENTIFIER .)
    GE              reduce using rule 100 (expression -> IDENTIFIER .)
    LE              reduce using rule 100 (expression -> IDENTIFIER .)
    QUESTION        reduce using rule 100 (expression -> IDENTIFIER .)
    NIL_COALESCE    reduce using rule 100 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 100 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 100 (expression -> IDENTIFIER .)
    LPAREN          shift and go to state 142


state 208

    (62) tuple_element -> expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RPAREN          reduce using rule 62 (tuple_element -> expression .)
    COMMA           reduce using rule 62 (tuple_element -> expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 209

    (61) tuple_element -> IDENTIFIER COLON expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RPAREN          reduce using rule 61 (tuple_element -> IDENTIFIER COLON expression .)
    COMMA           reduce using rule 61 (tuple_element -> IDENTIFIER COLON expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 210

    (147) class_declaration -> class_header LBRACE class_body RBRACE .

    NEWLINE         reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    LET             reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    VAR             reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    IF              reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    GUARD           reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    SWITCH          reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    IDENTIFIER      reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    RETURN          reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    BREAK           reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    CONTINUE        reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    SELF            reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    FOR             reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    WHILE           reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    FUNC            reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    CLASS           reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    LBRACKET        reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    MINUS           reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    PLUS            reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    NOT             reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    INT_LITERAL     reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    FLOAT_LITERAL   reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    STRING          reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    TRUE            reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    FALSE           reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    NIL             reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    $end            reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    DEFAULT         reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)
    CASE            reduce using rule 147 (class_declaration -> class_header LBRACE class_body RBRACE .)


state 211

    (149) class_body -> class_body class_member .

    RBRACE          reduce using rule 149 (class_body -> class_body class_member .)
    NEWLINE         reduce using rule 149 (class_body -> class_body class_member .)
    VAR             reduce using rule 149 (class_body -> class_body class_member .)
    LET             reduce using rule 149 (class_body -> class_body class_member .)
    INIT            reduce using rule 149 (class_body -> class_body class_member .)
    FUNC            reduce using rule 149 (class_body -> class_body class_member .)


state 212

    (157) property_declaration -> VAR IDENTIFIER . COLON type_annotation
    (159) property_declaration -> VAR IDENTIFIER . COLON tuple_type
    (161) computed_property -> VAR IDENTIFIER . COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE

    COLON           shift and go to state 248


state 213

    (158) property_declaration -> LET IDENTIFIER . COLON type_annotation
    (160) property_declaration -> LET IDENTIFIER . COLON tuple_type

    COLON           shift and go to state 249


state 214

    (162) init_declaration -> init_header LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    statement_list                 shift and go to state 250
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 215

    (165) method_declaration -> method_header LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    statement_list                 shift and go to state 251
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 216

    (163) init_header -> INIT LPAREN . parameter_list RPAREN
    (164) init_header -> INIT LPAREN . RPAREN
    (137) parameter_list -> . parameter_list COMMA parameter
    (138) parameter_list -> . parameter
    (139) parameter -> . IDENTIFIER COLON type_annotation
    (140) parameter -> . IDENTIFIER COLON type_annotation ASSIGN expression

    RPAREN          shift and go to state 253
    IDENTIFIER      shift and go to state 224

    parameter_list                 shift and go to state 252
    parameter                      shift and go to state 227

state 217

    (166) method_header -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN ARROW type_annotation
    (167) method_header -> FUNC IDENTIFIER . LPAREN RPAREN ARROW type_annotation
    (168) method_header -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN
    (169) method_header -> FUNC IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 254


state 218

    (44) array_elements -> array_elements COMMA expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RBRACKET        reduce using rule 44 (array_elements -> array_elements COMMA expression .)
    COMMA           reduce using rule 44 (array_elements -> array_elements COMMA expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 219

    (50) dictionary_pairs -> dictionary_pairs COMMA dictionary_pair .

    RBRACKET        reduce using rule 50 (dictionary_pairs -> dictionary_pairs COMMA dictionary_pair .)
    COMMA           reduce using rule 50 (dictionary_pairs -> dictionary_pairs COMMA dictionary_pair .)


state 220

    (52) dictionary_pair -> expression . COLON expression
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    COLON           shift and go to state 172
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 221

    (52) dictionary_pair -> expression COLON expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RBRACKET        reduce using rule 52 (dictionary_pair -> expression COLON expression .)
    COMMA           reduce using rule 52 (dictionary_pair -> expression COLON expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 222

    (105) for_header -> FOR IDENTIFIER IN range_expression .

    LBRACE          reduce using rule 105 (for_header -> FOR IDENTIFIER IN range_expression .)


state 223

    (106) for_header -> FOR IDENTIFIER IN expression .
    (107) range_expression -> expression . CLOSED_RANGE expression
    (108) range_expression -> expression . HALF_OPEN_RANGE expression
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          reduce using rule 106 (for_header -> FOR IDENTIFIER IN expression .)
    CLOSED_RANGE    shift and go to state 255
    HALF_OPEN_RANGE shift and go to state 256
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 224

    (139) parameter -> IDENTIFIER . COLON type_annotation
    (140) parameter -> IDENTIFIER . COLON type_annotation ASSIGN expression

    COLON           shift and go to state 257


state 225

    (133) func_header -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN ARROW type_annotation
    (135) func_header -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN
    (137) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 258
    COMMA           shift and go to state 259


state 226

    (134) func_header -> FUNC IDENTIFIER LPAREN RPAREN . ARROW type_annotation
    (136) func_header -> FUNC IDENTIFIER LPAREN RPAREN .

    ARROW           shift and go to state 260
    LBRACE          reduce using rule 136 (func_header -> FUNC IDENTIFIER LPAREN RPAREN .)


state 227

    (138) parameter_list -> parameter .

    RPAREN          reduce using rule 138 (parameter_list -> parameter .)
    COMMA           reduce using rule 138 (parameter_list -> parameter .)


state 228

    (20) variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 261

state 229

    (37) optional_type -> TYPE_INT QUESTION .

    ASSIGN          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    NEWLINE         reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    LET             reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    VAR             reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    IF              reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    GUARD           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    SWITCH          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    IDENTIFIER      reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    RETURN          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    BREAK           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    CONTINUE        reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    SELF            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    FOR             reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    WHILE           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    FUNC            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    CLASS           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    LBRACKET        reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    LPAREN          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    MINUS           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    PLUS            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    NOT             reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    INT_LITERAL     reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    FLOAT_LITERAL   reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    STRING          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    TRUE            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    FALSE           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    NIL             reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    $end            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    RBRACE          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    DEFAULT         reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    CASE            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    RPAREN          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    COMMA           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    RBRACKET        reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    COLON           reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    LBRACE          reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)
    INIT            reduce using rule 37 (optional_type -> TYPE_INT QUESTION .)


state 230

    (38) optional_type -> TYPE_DOUBLE QUESTION .

    ASSIGN          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    NEWLINE         reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    LET             reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    VAR             reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    IF              reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    GUARD           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    SWITCH          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    IDENTIFIER      reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    RETURN          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    BREAK           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    CONTINUE        reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    SELF            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    FOR             reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    WHILE           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    FUNC            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    CLASS           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    LBRACKET        reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    LPAREN          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    MINUS           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    PLUS            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    NOT             reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    INT_LITERAL     reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    FLOAT_LITERAL   reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    STRING          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    TRUE            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    FALSE           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    NIL             reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    $end            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    RBRACE          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    DEFAULT         reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    CASE            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    RPAREN          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    COMMA           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    RBRACKET        reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    COLON           reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    LBRACE          reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)
    INIT            reduce using rule 38 (optional_type -> TYPE_DOUBLE QUESTION .)


state 231

    (39) optional_type -> TYPE_BOOL QUESTION .

    ASSIGN          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    NEWLINE         reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    LET             reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    VAR             reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    IF              reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    GUARD           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    SWITCH          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    IDENTIFIER      reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    RETURN          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    BREAK           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    CONTINUE        reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    SELF            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    FOR             reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    WHILE           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    FUNC            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    CLASS           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    LBRACKET        reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    LPAREN          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    MINUS           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    PLUS            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    NOT             reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    INT_LITERAL     reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    FLOAT_LITERAL   reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    STRING          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    TRUE            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    FALSE           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    NIL             reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    $end            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    RBRACE          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    DEFAULT         reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    CASE            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    RPAREN          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    COMMA           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    RBRACKET        reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    COLON           reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    LBRACE          reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)
    INIT            reduce using rule 39 (optional_type -> TYPE_BOOL QUESTION .)


state 232

    (40) optional_type -> TYPE_STRING QUESTION .

    ASSIGN          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    NEWLINE         reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    LET             reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    VAR             reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    IF              reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    GUARD           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    SWITCH          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    IDENTIFIER      reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    RETURN          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    BREAK           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    CONTINUE        reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    SELF            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    FOR             reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    WHILE           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    FUNC            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    CLASS           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    LBRACKET        reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    LPAREN          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    MINUS           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    PLUS            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    NOT             reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    INT_LITERAL     reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    FLOAT_LITERAL   reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    STRING          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    TRUE            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    FALSE           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    NIL             reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    $end            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    RBRACE          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    DEFAULT         reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    CASE            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    RPAREN          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    COMMA           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    RBRACKET        reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    COLON           reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    LBRACE          reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)
    INIT            reduce using rule 40 (optional_type -> TYPE_STRING QUESTION .)


state 233

    (53) tuple_type -> LPAREN tuple_type_elements . RPAREN
    (54) tuple_type_elements -> tuple_type_elements . COMMA tuple_type_element

    RPAREN          shift and go to state 262
    COMMA           shift and go to state 263


state 234

    (55) tuple_type_elements -> tuple_type_element .

    RPAREN          reduce using rule 55 (tuple_type_elements -> tuple_type_element .)
    COMMA           reduce using rule 55 (tuple_type_elements -> tuple_type_element .)


state 235

    (56) tuple_type_element -> IDENTIFIER . COLON type_annotation
    (36) type_annotation -> IDENTIFIER .

    COLON           shift and go to state 264
    RPAREN          reduce using rule 36 (type_annotation -> IDENTIFIER .)
    COMMA           reduce using rule 36 (type_annotation -> IDENTIFIER .)


state 236

    (57) tuple_type_element -> type_annotation .

    RPAREN          reduce using rule 57 (tuple_type_element -> type_annotation .)
    COMMA           reduce using rule 57 (tuple_type_element -> type_annotation .)


state 237

    (35) type_annotation -> tuple_type .

    RPAREN          reduce using rule 35 (type_annotation -> tuple_type .)
    COMMA           reduce using rule 35 (type_annotation -> tuple_type .)
    RBRACKET        reduce using rule 35 (type_annotation -> tuple_type .)
    COLON           reduce using rule 35 (type_annotation -> tuple_type .)
    ASSIGN          reduce using rule 35 (type_annotation -> tuple_type .)
    LBRACE          reduce using rule 35 (type_annotation -> tuple_type .)


state 238

    (41) array_type -> LBRACKET type_annotation . RBRACKET
    (47) dictionary_type -> LBRACKET type_annotation . COLON type_annotation RBRACKET

    RBRACKET        shift and go to state 265
    COLON           shift and go to state 266


state 239

    (145) argument_list -> argument_list COMMA expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RPAREN          reduce using rule 145 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 145 (argument_list -> argument_list COMMA expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 240

    (91) expression -> expression QUESTION expression COLON expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACKET        reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    DOT             reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    NEWLINE         reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    LET             reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    VAR             reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    IF              reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    GUARD           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    SWITCH          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    IDENTIFIER      reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    RETURN          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    BREAK           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    CONTINUE        reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    SELF            reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    FOR             reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    WHILE           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    FUNC            reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    CLASS           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    LPAREN          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    NOT             reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    INT_LITERAL     reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    FLOAT_LITERAL   reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    STRING          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    TRUE            reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    FALSE           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    NIL             reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    $end            reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    LBRACE          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    ELSE            reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    RPAREN          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    COMMA           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    RBRACE          reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    DEFAULT         reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    CASE            reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    COLON           reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    RBRACKET        reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    CLOSED_RANGE    reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    HALF_OPEN_RANGE reduce using rule 91 (expression -> expression QUESTION expression COLON expression .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! PLUS            [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! MINUS           [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! TIMES           [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! DIVIDE          [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! MODULO          [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! AND             [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! OR              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! EQ              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! NE              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! GT              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! LT              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! GE              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! LE              [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! QUESTION        [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! NIL_COALESCE    [ reduce using rule 91 (expression -> expression QUESTION expression COLON expression .) ]
  ! LBRACKET        [ shift and go to state 53 ]
  ! DOT             [ shift and go to state 54 ]


state 241

    (21) variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 267

state 242

    (109) if_statement -> IF expression LBRACE statement_list RBRACE .
    (110) if_statement -> IF expression LBRACE statement_list RBRACE . ELSE LBRACE statement_list RBRACE
    (111) if_statement -> IF expression LBRACE statement_list RBRACE . else_if_chain
    (112) if_statement -> IF expression LBRACE statement_list RBRACE . else_if_chain ELSE LBRACE statement_list RBRACE
    (113) else_if_chain -> . else_if_chain else_if_statement
    (114) else_if_chain -> . else_if_statement
    (115) else_if_statement -> . ELSE IF expression LBRACE statement_list RBRACE

    NEWLINE         reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    LET             reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    VAR             reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    IF              reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    SELF            reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    FOR             reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    NOT             reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    STRING          reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    NIL             reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    $end            reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    CASE            reduce using rule 109 (if_statement -> IF expression LBRACE statement_list RBRACE .)
    ELSE            shift and go to state 268

    else_if_chain                  shift and go to state 269
    else_if_statement              shift and go to state 270

state 243

    (102) expression -> IDENTIFIER LPAREN argument_list RPAREN .

    LBRACE          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DOT             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULO          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NE              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    QUESTION        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NIL_COALESCE    reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    ELSE            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEWLINE         reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LET             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GUARD           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SELF            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CLASS           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NOT             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT_LITERAL     reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT_LITERAL   reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NIL             reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CLOSED_RANGE    reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    HALF_OPEN_RANGE reduce using rule 102 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 244

    (116) guard_statement -> GUARD expression ELSE LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 271
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 245

    (124) case_list -> optional_newlines . case_clause
    (130) optional_newlines -> optional_newlines . NEWLINE
    (125) case_clause -> . CASE case_patterns COLON optional_newlines case_body

    NEWLINE         shift and go to state 247
    CASE            shift and go to state 273

    case_clause                    shift and go to state 272

state 246

    (121) switch_statement -> SWITCH expression LBRACE optional_newlines case_list . optional_newlines RBRACE
    (122) switch_statement -> SWITCH expression LBRACE optional_newlines case_list . default_case optional_newlines RBRACE
    (123) case_list -> case_list . optional_newlines case_clause
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (129) default_case -> . DEFAULT COLON optional_newlines case_body
    (170) empty -> .

    DEFAULT         shift and go to state 276
    RBRACE          reduce using rule 170 (empty -> .)
    NEWLINE         reduce using rule 170 (empty -> .)
    CASE            reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 274
    default_case                   shift and go to state 275
    empty                          shift and go to state 204

state 247

    (130) optional_newlines -> optional_newlines NEWLINE .

    NEWLINE         reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .)
    CASE            reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .)
    RBRACE          reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .)
    GET             reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .)


state 248

    (157) property_declaration -> VAR IDENTIFIER COLON . type_annotation
    (159) property_declaration -> VAR IDENTIFIER COLON . tuple_type
    (161) computed_property -> VAR IDENTIFIER COLON . type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LPAREN          shift and go to state 185
    LBRACKET        shift and go to state 186

    type_annotation                shift and go to state 277
    tuple_type                     shift and go to state 278
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184

state 249

    (158) property_declaration -> LET IDENTIFIER COLON . type_annotation
    (160) property_declaration -> LET IDENTIFIER COLON . tuple_type
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LPAREN          shift and go to state 185
    LBRACKET        shift and go to state 186

    type_annotation                shift and go to state 279
    tuple_type                     shift and go to state 280
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184

state 250

    (162) init_declaration -> init_header LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 281
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 251

    (165) method_declaration -> method_header LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 282
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 252

    (163) init_header -> INIT LPAREN parameter_list . RPAREN
    (137) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 283
    COMMA           shift and go to state 259


state 253

    (164) init_header -> INIT LPAREN RPAREN .

    LBRACE          reduce using rule 164 (init_header -> INIT LPAREN RPAREN .)


state 254

    (166) method_header -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN ARROW type_annotation
    (167) method_header -> FUNC IDENTIFIER LPAREN . RPAREN ARROW type_annotation
    (168) method_header -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN
    (169) method_header -> FUNC IDENTIFIER LPAREN . RPAREN
    (137) parameter_list -> . parameter_list COMMA parameter
    (138) parameter_list -> . parameter
    (139) parameter -> . IDENTIFIER COLON type_annotation
    (140) parameter -> . IDENTIFIER COLON type_annotation ASSIGN expression

    RPAREN          shift and go to state 285
    IDENTIFIER      shift and go to state 224

    parameter_list                 shift and go to state 284
    parameter                      shift and go to state 227

state 255

    (107) range_expression -> expression CLOSED_RANGE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 286

state 256

    (108) range_expression -> expression HALF_OPEN_RANGE . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 287

state 257

    (139) parameter -> IDENTIFIER COLON . type_annotation
    (140) parameter -> IDENTIFIER COLON . type_annotation ASSIGN expression
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 288
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 258

    (133) func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . ARROW type_annotation
    (135) func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN .

    ARROW           shift and go to state 289
    LBRACE          reduce using rule 135 (func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN .)


state 259

    (137) parameter_list -> parameter_list COMMA . parameter
    (139) parameter -> . IDENTIFIER COLON type_annotation
    (140) parameter -> . IDENTIFIER COLON type_annotation ASSIGN expression

    IDENTIFIER      shift and go to state 224

    parameter                      shift and go to state 290

state 260

    (134) func_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 291
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 261

    (20) variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    LET             reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    VAR             reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    IF              reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    GUARD           reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    SWITCH          reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    IDENTIFIER      reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    RETURN          reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    BREAK           reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    CONTINUE        reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    SELF            reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    FOR             reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    WHILE           reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    FUNC            reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    CLASS           reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    LPAREN          reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    NOT             reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    INT_LITERAL     reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    STRING          reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    TRUE            reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    FALSE           reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    NIL             reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    $end            reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    RBRACE          reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    DEFAULT         reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    CASE            reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 20 (variable_declaration -> LET IDENTIFIER COLON type_annotation ASSIGN expression .) ]


state 262

    (53) tuple_type -> LPAREN tuple_type_elements RPAREN .

    NEWLINE         reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    LET             reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    VAR             reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    IF              reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    GUARD           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    SWITCH          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    IDENTIFIER      reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    RETURN          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    BREAK           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    CONTINUE        reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    SELF            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    FOR             reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    WHILE           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    FUNC            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    CLASS           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    LBRACKET        reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    LPAREN          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    MINUS           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    PLUS            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    NOT             reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    INT_LITERAL     reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    FLOAT_LITERAL   reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    STRING          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    TRUE            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    FALSE           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    NIL             reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    $end            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    RBRACE          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    ASSIGN          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    DEFAULT         reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    CASE            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    RPAREN          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    COMMA           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    RBRACKET        reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    COLON           reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    INIT            reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)
    LBRACE          reduce using rule 53 (tuple_type -> LPAREN tuple_type_elements RPAREN .)


state 263

    (54) tuple_type_elements -> tuple_type_elements COMMA . tuple_type_element
    (56) tuple_type_element -> . IDENTIFIER COLON type_annotation
    (57) tuple_type_element -> . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    IDENTIFIER      shift and go to state 235
    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    tuple_type_element             shift and go to state 292
    type_annotation                shift and go to state 236
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 264

    (56) tuple_type_element -> IDENTIFIER COLON . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 293
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 265

    (41) array_type -> LBRACKET type_annotation RBRACKET .

    ASSIGN          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    NEWLINE         reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    LET             reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    VAR             reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    IF              reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    GUARD           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    SWITCH          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    IDENTIFIER      reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    RETURN          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    BREAK           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    CONTINUE        reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    SELF            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    FOR             reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    WHILE           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    FUNC            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    CLASS           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    LBRACKET        reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    LPAREN          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    MINUS           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    PLUS            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    NOT             reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    INT_LITERAL     reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    FLOAT_LITERAL   reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    STRING          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    TRUE            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    FALSE           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    NIL             reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    $end            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    RBRACE          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    DEFAULT         reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    CASE            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    RPAREN          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    COMMA           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    RBRACKET        reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    COLON           reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    LBRACE          reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)
    INIT            reduce using rule 41 (array_type -> LBRACKET type_annotation RBRACKET .)


state 266

    (47) dictionary_type -> LBRACKET type_annotation COLON . type_annotation RBRACKET
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 294
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 267

    (21) variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    NEWLINE         reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    LET             reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    VAR             reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    IF              reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    GUARD           reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    SWITCH          reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    IDENTIFIER      reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    RETURN          reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    BREAK           reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    CONTINUE        reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    SELF            reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    FOR             reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    WHILE           reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    FUNC            reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    CLASS           reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    LPAREN          reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    NOT             reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    INT_LITERAL     reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    FLOAT_LITERAL   reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    STRING          reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    TRUE            reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    FALSE           reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    NIL             reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    $end            reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    RBRACE          reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    DEFAULT         reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    CASE            reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69

  ! LBRACKET        [ reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 21 (variable_declaration -> VAR IDENTIFIER COLON type_annotation ASSIGN expression .) ]


state 268

    (110) if_statement -> IF expression LBRACE statement_list RBRACE ELSE . LBRACE statement_list RBRACE
    (115) else_if_statement -> ELSE . IF expression LBRACE statement_list RBRACE

    LBRACE          shift and go to state 296
    IF              shift and go to state 295


state 269

    (111) if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .
    (112) if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain . ELSE LBRACE statement_list RBRACE
    (113) else_if_chain -> else_if_chain . else_if_statement
    (115) else_if_statement -> . ELSE IF expression LBRACE statement_list RBRACE

    NEWLINE         reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    LET             reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    VAR             reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    IF              reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    GUARD           reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    SWITCH          reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    IDENTIFIER      reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    RETURN          reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    BREAK           reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    CONTINUE        reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    SELF            reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    FOR             reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    WHILE           reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    FUNC            reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    CLASS           reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    LBRACKET        reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    LPAREN          reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    MINUS           reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    PLUS            reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    NOT             reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    INT_LITERAL     reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    FLOAT_LITERAL   reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    STRING          reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    TRUE            reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    FALSE           reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    NIL             reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    $end            reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    RBRACE          reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    DEFAULT         reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    CASE            reduce using rule 111 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain .)
    ELSE            shift and go to state 297

    else_if_statement              shift and go to state 298

state 270

    (114) else_if_chain -> else_if_statement .

    ELSE            reduce using rule 114 (else_if_chain -> else_if_statement .)
    NEWLINE         reduce using rule 114 (else_if_chain -> else_if_statement .)
    LET             reduce using rule 114 (else_if_chain -> else_if_statement .)
    VAR             reduce using rule 114 (else_if_chain -> else_if_statement .)
    IF              reduce using rule 114 (else_if_chain -> else_if_statement .)
    GUARD           reduce using rule 114 (else_if_chain -> else_if_statement .)
    SWITCH          reduce using rule 114 (else_if_chain -> else_if_statement .)
    IDENTIFIER      reduce using rule 114 (else_if_chain -> else_if_statement .)
    RETURN          reduce using rule 114 (else_if_chain -> else_if_statement .)
    BREAK           reduce using rule 114 (else_if_chain -> else_if_statement .)
    CONTINUE        reduce using rule 114 (else_if_chain -> else_if_statement .)
    SELF            reduce using rule 114 (else_if_chain -> else_if_statement .)
    FOR             reduce using rule 114 (else_if_chain -> else_if_statement .)
    WHILE           reduce using rule 114 (else_if_chain -> else_if_statement .)
    FUNC            reduce using rule 114 (else_if_chain -> else_if_statement .)
    CLASS           reduce using rule 114 (else_if_chain -> else_if_statement .)
    LBRACKET        reduce using rule 114 (else_if_chain -> else_if_statement .)
    LPAREN          reduce using rule 114 (else_if_chain -> else_if_statement .)
    MINUS           reduce using rule 114 (else_if_chain -> else_if_statement .)
    PLUS            reduce using rule 114 (else_if_chain -> else_if_statement .)
    NOT             reduce using rule 114 (else_if_chain -> else_if_statement .)
    INT_LITERAL     reduce using rule 114 (else_if_chain -> else_if_statement .)
    FLOAT_LITERAL   reduce using rule 114 (else_if_chain -> else_if_statement .)
    STRING          reduce using rule 114 (else_if_chain -> else_if_statement .)
    TRUE            reduce using rule 114 (else_if_chain -> else_if_statement .)
    FALSE           reduce using rule 114 (else_if_chain -> else_if_statement .)
    NIL             reduce using rule 114 (else_if_chain -> else_if_statement .)
    $end            reduce using rule 114 (else_if_chain -> else_if_statement .)
    RBRACE          reduce using rule 114 (else_if_chain -> else_if_statement .)
    DEFAULT         reduce using rule 114 (else_if_chain -> else_if_statement .)
    CASE            reduce using rule 114 (else_if_chain -> else_if_statement .)


state 271

    (116) guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    LET             reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    VAR             reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    SELF            reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    FOR             reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    NOT             reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    STRING          reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    NIL             reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    $end            reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)
    CASE            reduce using rule 116 (guard_statement -> GUARD expression ELSE LBRACE statement_list RBRACE .)


state 272

    (124) case_list -> optional_newlines case_clause .

    DEFAULT         reduce using rule 124 (case_list -> optional_newlines case_clause .)
    RBRACE          reduce using rule 124 (case_list -> optional_newlines case_clause .)
    NEWLINE         reduce using rule 124 (case_list -> optional_newlines case_clause .)
    CASE            reduce using rule 124 (case_list -> optional_newlines case_clause .)


state 273

    (125) case_clause -> CASE . case_patterns COLON optional_newlines case_body
    (127) case_patterns -> . case_patterns COMMA expression
    (128) case_patterns -> . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    case_patterns                  shift and go to state 299
    expression                     shift and go to state 300

state 274

    (121) switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines . RBRACE
    (123) case_list -> case_list optional_newlines . case_clause
    (130) optional_newlines -> optional_newlines . NEWLINE
    (125) case_clause -> . CASE case_patterns COLON optional_newlines case_body

    RBRACE          shift and go to state 301
    NEWLINE         shift and go to state 247
    CASE            shift and go to state 273

    case_clause                    shift and go to state 302

state 275

    (122) switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case . optional_newlines RBRACE
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    RBRACE          reduce using rule 170 (empty -> .)
    NEWLINE         reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 303
    empty                          shift and go to state 204

state 276

    (129) default_case -> DEFAULT . COLON optional_newlines case_body

    COLON           shift and go to state 304


state 277

    (157) property_declaration -> VAR IDENTIFIER COLON type_annotation .
    (161) computed_property -> VAR IDENTIFIER COLON type_annotation . LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE

    RBRACE          reduce using rule 157 (property_declaration -> VAR IDENTIFIER COLON type_annotation .)
    NEWLINE         reduce using rule 157 (property_declaration -> VAR IDENTIFIER COLON type_annotation .)
    VAR             reduce using rule 157 (property_declaration -> VAR IDENTIFIER COLON type_annotation .)
    LET             reduce using rule 157 (property_declaration -> VAR IDENTIFIER COLON type_annotation .)
    INIT            reduce using rule 157 (property_declaration -> VAR IDENTIFIER COLON type_annotation .)
    FUNC            reduce using rule 157 (property_declaration -> VAR IDENTIFIER COLON type_annotation .)
    LBRACE          shift and go to state 305


state 278

    (159) property_declaration -> VAR IDENTIFIER COLON tuple_type .
    (35) type_annotation -> tuple_type .

  ! reduce/reduce conflict for RBRACE resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for VAR resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for LET resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for INIT resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for FUNC resolved using rule 35 (type_annotation -> tuple_type .)
    LBRACE          reduce using rule 35 (type_annotation -> tuple_type .)
    RBRACE          reduce using rule 35 (type_annotation -> tuple_type .)
    NEWLINE         reduce using rule 35 (type_annotation -> tuple_type .)
    VAR             reduce using rule 35 (type_annotation -> tuple_type .)
    LET             reduce using rule 35 (type_annotation -> tuple_type .)
    INIT            reduce using rule 35 (type_annotation -> tuple_type .)
    FUNC            reduce using rule 35 (type_annotation -> tuple_type .)

  ! RBRACE          [ reduce using rule 159 (property_declaration -> VAR IDENTIFIER COLON tuple_type .) ]
  ! NEWLINE         [ reduce using rule 159 (property_declaration -> VAR IDENTIFIER COLON tuple_type .) ]
  ! VAR             [ reduce using rule 159 (property_declaration -> VAR IDENTIFIER COLON tuple_type .) ]
  ! LET             [ reduce using rule 159 (property_declaration -> VAR IDENTIFIER COLON tuple_type .) ]
  ! INIT            [ reduce using rule 159 (property_declaration -> VAR IDENTIFIER COLON tuple_type .) ]
  ! FUNC            [ reduce using rule 159 (property_declaration -> VAR IDENTIFIER COLON tuple_type .) ]


state 279

    (158) property_declaration -> LET IDENTIFIER COLON type_annotation .

    RBRACE          reduce using rule 158 (property_declaration -> LET IDENTIFIER COLON type_annotation .)
    NEWLINE         reduce using rule 158 (property_declaration -> LET IDENTIFIER COLON type_annotation .)
    VAR             reduce using rule 158 (property_declaration -> LET IDENTIFIER COLON type_annotation .)
    LET             reduce using rule 158 (property_declaration -> LET IDENTIFIER COLON type_annotation .)
    INIT            reduce using rule 158 (property_declaration -> LET IDENTIFIER COLON type_annotation .)
    FUNC            reduce using rule 158 (property_declaration -> LET IDENTIFIER COLON type_annotation .)


state 280

    (160) property_declaration -> LET IDENTIFIER COLON tuple_type .
    (35) type_annotation -> tuple_type .

  ! reduce/reduce conflict for RBRACE resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for VAR resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for LET resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for INIT resolved using rule 35 (type_annotation -> tuple_type .)
  ! reduce/reduce conflict for FUNC resolved using rule 35 (type_annotation -> tuple_type .)
    RBRACE          reduce using rule 35 (type_annotation -> tuple_type .)
    NEWLINE         reduce using rule 35 (type_annotation -> tuple_type .)
    VAR             reduce using rule 35 (type_annotation -> tuple_type .)
    LET             reduce using rule 35 (type_annotation -> tuple_type .)
    INIT            reduce using rule 35 (type_annotation -> tuple_type .)
    FUNC            reduce using rule 35 (type_annotation -> tuple_type .)

  ! RBRACE          [ reduce using rule 160 (property_declaration -> LET IDENTIFIER COLON tuple_type .) ]
  ! NEWLINE         [ reduce using rule 160 (property_declaration -> LET IDENTIFIER COLON tuple_type .) ]
  ! VAR             [ reduce using rule 160 (property_declaration -> LET IDENTIFIER COLON tuple_type .) ]
  ! LET             [ reduce using rule 160 (property_declaration -> LET IDENTIFIER COLON tuple_type .) ]
  ! INIT            [ reduce using rule 160 (property_declaration -> LET IDENTIFIER COLON tuple_type .) ]
  ! FUNC            [ reduce using rule 160 (property_declaration -> LET IDENTIFIER COLON tuple_type .) ]


state 281

    (162) init_declaration -> init_header LBRACE statement_list RBRACE .

    RBRACE          reduce using rule 162 (init_declaration -> init_header LBRACE statement_list RBRACE .)
    NEWLINE         reduce using rule 162 (init_declaration -> init_header LBRACE statement_list RBRACE .)
    VAR             reduce using rule 162 (init_declaration -> init_header LBRACE statement_list RBRACE .)
    LET             reduce using rule 162 (init_declaration -> init_header LBRACE statement_list RBRACE .)
    INIT            reduce using rule 162 (init_declaration -> init_header LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 162 (init_declaration -> init_header LBRACE statement_list RBRACE .)


state 282

    (165) method_declaration -> method_header LBRACE statement_list RBRACE .

    RBRACE          reduce using rule 165 (method_declaration -> method_header LBRACE statement_list RBRACE .)
    NEWLINE         reduce using rule 165 (method_declaration -> method_header LBRACE statement_list RBRACE .)
    VAR             reduce using rule 165 (method_declaration -> method_header LBRACE statement_list RBRACE .)
    LET             reduce using rule 165 (method_declaration -> method_header LBRACE statement_list RBRACE .)
    INIT            reduce using rule 165 (method_declaration -> method_header LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 165 (method_declaration -> method_header LBRACE statement_list RBRACE .)


state 283

    (163) init_header -> INIT LPAREN parameter_list RPAREN .

    LBRACE          reduce using rule 163 (init_header -> INIT LPAREN parameter_list RPAREN .)


state 284

    (166) method_header -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN ARROW type_annotation
    (168) method_header -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN
    (137) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 306
    COMMA           shift and go to state 259


state 285

    (167) method_header -> FUNC IDENTIFIER LPAREN RPAREN . ARROW type_annotation
    (169) method_header -> FUNC IDENTIFIER LPAREN RPAREN .

    ARROW           shift and go to state 307
    LBRACE          reduce using rule 169 (method_header -> FUNC IDENTIFIER LPAREN RPAREN .)


state 286

    (107) range_expression -> expression CLOSED_RANGE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          reduce using rule 107 (range_expression -> expression CLOSED_RANGE expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 287

    (108) range_expression -> expression HALF_OPEN_RANGE expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          reduce using rule 108 (range_expression -> expression HALF_OPEN_RANGE expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 288

    (139) parameter -> IDENTIFIER COLON type_annotation .
    (140) parameter -> IDENTIFIER COLON type_annotation . ASSIGN expression

    RPAREN          reduce using rule 139 (parameter -> IDENTIFIER COLON type_annotation .)
    COMMA           reduce using rule 139 (parameter -> IDENTIFIER COLON type_annotation .)
    ASSIGN          shift and go to state 308


state 289

    (133) func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 309
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 290

    (137) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 137 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 137 (parameter_list -> parameter_list COMMA parameter .)


state 291

    (134) func_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation .

    LBRACE          reduce using rule 134 (func_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation .)


state 292

    (54) tuple_type_elements -> tuple_type_elements COMMA tuple_type_element .

    RPAREN          reduce using rule 54 (tuple_type_elements -> tuple_type_elements COMMA tuple_type_element .)
    COMMA           reduce using rule 54 (tuple_type_elements -> tuple_type_elements COMMA tuple_type_element .)


state 293

    (56) tuple_type_element -> IDENTIFIER COLON type_annotation .

    RPAREN          reduce using rule 56 (tuple_type_element -> IDENTIFIER COLON type_annotation .)
    COMMA           reduce using rule 56 (tuple_type_element -> IDENTIFIER COLON type_annotation .)


state 294

    (47) dictionary_type -> LBRACKET type_annotation COLON type_annotation . RBRACKET

    RBRACKET        shift and go to state 310


state 295

    (115) else_if_statement -> ELSE IF . expression LBRACE statement_list RBRACE
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 311

state 296

    (110) if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement_list                 shift and go to state 312
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 297

    (112) if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE . LBRACE statement_list RBRACE
    (115) else_if_statement -> ELSE . IF expression LBRACE statement_list RBRACE

    LBRACE          shift and go to state 313
    IF              shift and go to state 295


state 298

    (113) else_if_chain -> else_if_chain else_if_statement .

    ELSE            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    NEWLINE         reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    LET             reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    VAR             reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    IF              reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    GUARD           reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    SWITCH          reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    IDENTIFIER      reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    RETURN          reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    BREAK           reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    CONTINUE        reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    SELF            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    FOR             reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    WHILE           reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    FUNC            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    CLASS           reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    LBRACKET        reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    LPAREN          reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    MINUS           reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    PLUS            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    NOT             reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    INT_LITERAL     reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    FLOAT_LITERAL   reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    STRING          reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    TRUE            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    FALSE           reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    NIL             reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    $end            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    RBRACE          reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    DEFAULT         reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)
    CASE            reduce using rule 113 (else_if_chain -> else_if_chain else_if_statement .)


state 299

    (125) case_clause -> CASE case_patterns . COLON optional_newlines case_body
    (127) case_patterns -> case_patterns . COMMA expression

    COLON           shift and go to state 314
    COMMA           shift and go to state 315


state 300

    (128) case_patterns -> expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    COLON           reduce using rule 128 (case_patterns -> expression .)
    COMMA           reduce using rule 128 (case_patterns -> expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 301

    (121) switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .

    NEWLINE         reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    LET             reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    VAR             reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    IF              reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    GUARD           reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    SWITCH          reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    IDENTIFIER      reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    RETURN          reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    BREAK           reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    CONTINUE        reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    SELF            reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    FOR             reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    WHILE           reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    FUNC            reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    CLASS           reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    LBRACKET        reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    LPAREN          reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    MINUS           reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    PLUS            reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    NOT             reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    INT_LITERAL     reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    FLOAT_LITERAL   reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    STRING          reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    TRUE            reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    FALSE           reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    NIL             reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    $end            reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    RBRACE          reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    DEFAULT         reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)
    CASE            reduce using rule 121 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE .)


state 302

    (123) case_list -> case_list optional_newlines case_clause .

    DEFAULT         reduce using rule 123 (case_list -> case_list optional_newlines case_clause .)
    RBRACE          reduce using rule 123 (case_list -> case_list optional_newlines case_clause .)
    NEWLINE         reduce using rule 123 (case_list -> case_list optional_newlines case_clause .)
    CASE            reduce using rule 123 (case_list -> case_list optional_newlines case_clause .)


state 303

    (122) switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines . RBRACE
    (130) optional_newlines -> optional_newlines . NEWLINE

    RBRACE          shift and go to state 316
    NEWLINE         shift and go to state 247


state 304

    (129) default_case -> DEFAULT COLON . optional_newlines case_body
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    NEWLINE         reduce using rule 170 (empty -> .)
    LET             reduce using rule 170 (empty -> .)
    VAR             reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    GUARD           reduce using rule 170 (empty -> .)
    SWITCH          reduce using rule 170 (empty -> .)
    IDENTIFIER      reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    BREAK           reduce using rule 170 (empty -> .)
    CONTINUE        reduce using rule 170 (empty -> .)
    SELF            reduce using rule 170 (empty -> .)
    FOR             reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FUNC            reduce using rule 170 (empty -> .)
    CLASS           reduce using rule 170 (empty -> .)
    LBRACKET        reduce using rule 170 (empty -> .)
    LPAREN          reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    NOT             reduce using rule 170 (empty -> .)
    INT_LITERAL     reduce using rule 170 (empty -> .)
    FLOAT_LITERAL   reduce using rule 170 (empty -> .)
    STRING          reduce using rule 170 (empty -> .)
    TRUE            reduce using rule 170 (empty -> .)
    FALSE           reduce using rule 170 (empty -> .)
    NIL             reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 317
    empty                          shift and go to state 204

state 305

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE . optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    GET             reduce using rule 170 (empty -> .)
    NEWLINE         reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 318
    empty                          shift and go to state 204

state 306

    (166) method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . ARROW type_annotation
    (168) method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN .

    ARROW           shift and go to state 319
    LBRACE          reduce using rule 168 (method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN .)


state 307

    (167) method_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 320
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 308

    (140) parameter -> IDENTIFIER COLON type_annotation ASSIGN . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 321

state 309

    (133) func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation .

    LBRACE          reduce using rule 133 (func_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation .)


state 310

    (47) dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .

    ASSIGN          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    NEWLINE         reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    LET             reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    VAR             reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    IF              reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    GUARD           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    SWITCH          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    IDENTIFIER      reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    RETURN          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    BREAK           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    CONTINUE        reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    SELF            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    FOR             reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    WHILE           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    FUNC            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    CLASS           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    LBRACKET        reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    LPAREN          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    MINUS           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    PLUS            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    NOT             reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    INT_LITERAL     reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    FLOAT_LITERAL   reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    STRING          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    TRUE            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    FALSE           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    NIL             reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    $end            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    RBRACE          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    DEFAULT         reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    CASE            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    RPAREN          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    COMMA           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    RBRACKET        reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    COLON           reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    LBRACE          reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)
    INIT            reduce using rule 47 (dictionary_type -> LBRACKET type_annotation COLON type_annotation RBRACKET .)


state 311

    (115) else_if_statement -> ELSE IF expression . LBRACE statement_list RBRACE
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    LBRACE          shift and go to state 322
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 312

    (110) if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 323
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 313

    (112) if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement_list                 shift and go to state 324
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 314

    (125) case_clause -> CASE case_patterns COLON . optional_newlines case_body
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    NEWLINE         reduce using rule 170 (empty -> .)
    LET             reduce using rule 170 (empty -> .)
    VAR             reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    GUARD           reduce using rule 170 (empty -> .)
    SWITCH          reduce using rule 170 (empty -> .)
    IDENTIFIER      reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    BREAK           reduce using rule 170 (empty -> .)
    CONTINUE        reduce using rule 170 (empty -> .)
    SELF            reduce using rule 170 (empty -> .)
    FOR             reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FUNC            reduce using rule 170 (empty -> .)
    CLASS           reduce using rule 170 (empty -> .)
    LBRACKET        reduce using rule 170 (empty -> .)
    LPAREN          reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    NOT             reduce using rule 170 (empty -> .)
    INT_LITERAL     reduce using rule 170 (empty -> .)
    FLOAT_LITERAL   reduce using rule 170 (empty -> .)
    STRING          reduce using rule 170 (empty -> .)
    TRUE            reduce using rule 170 (empty -> .)
    FALSE           reduce using rule 170 (empty -> .)
    NIL             reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 325
    empty                          shift and go to state 204

state 315

    (127) case_patterns -> case_patterns COMMA . expression
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 81
    SELF            shift and go to state 82

    expression                     shift and go to state 326

state 316

    (122) switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .

    NEWLINE         reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    LET             reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    VAR             reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    IF              reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    GUARD           reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    SWITCH          reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    IDENTIFIER      reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    RETURN          reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    BREAK           reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    CONTINUE        reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    SELF            reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    FOR             reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    WHILE           reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    FUNC            reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    CLASS           reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    LBRACKET        reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    LPAREN          reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    MINUS           reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    PLUS            reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    NOT             reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    INT_LITERAL     reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    FLOAT_LITERAL   reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    STRING          reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    TRUE            reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    FALSE           reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    NIL             reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    $end            reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    RBRACE          reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    DEFAULT         reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)
    CASE            reduce using rule 122 (switch_statement -> SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE .)


state 317

    (129) default_case -> DEFAULT COLON optional_newlines . case_body
    (130) optional_newlines -> optional_newlines . NEWLINE
    (126) case_body -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 328
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    case_body                      shift and go to state 327
    statement_list                 shift and go to state 329
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 318

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines . GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
    (130) optional_newlines -> optional_newlines . NEWLINE

    GET             shift and go to state 330
    NEWLINE         shift and go to state 247


state 319

    (166) method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW . type_annotation
    (28) type_annotation -> . TYPE_INT
    (29) type_annotation -> . TYPE_DOUBLE
    (30) type_annotation -> . TYPE_BOOL
    (31) type_annotation -> . TYPE_STRING
    (32) type_annotation -> . array_type
    (33) type_annotation -> . dictionary_type
    (34) type_annotation -> . optional_type
    (35) type_annotation -> . tuple_type
    (36) type_annotation -> . IDENTIFIER
    (41) array_type -> . LBRACKET type_annotation RBRACKET
    (47) dictionary_type -> . LBRACKET type_annotation COLON type_annotation RBRACKET
    (37) optional_type -> . TYPE_INT QUESTION
    (38) optional_type -> . TYPE_DOUBLE QUESTION
    (39) optional_type -> . TYPE_BOOL QUESTION
    (40) optional_type -> . TYPE_STRING QUESTION
    (53) tuple_type -> . LPAREN tuple_type_elements RPAREN

    TYPE_INT        shift and go to state 178
    TYPE_DOUBLE     shift and go to state 179
    TYPE_BOOL       shift and go to state 180
    TYPE_STRING     shift and go to state 181
    IDENTIFIER      shift and go to state 175
    LBRACKET        shift and go to state 186
    LPAREN          shift and go to state 185

    type_annotation                shift and go to state 331
    array_type                     shift and go to state 182
    dictionary_type                shift and go to state 183
    optional_type                  shift and go to state 184
    tuple_type                     shift and go to state 237

state 320

    (167) method_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation .

    LBRACE          reduce using rule 167 (method_header -> FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation .)


state 321

    (140) parameter -> IDENTIFIER COLON type_annotation ASSIGN expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    RPAREN          reduce using rule 140 (parameter -> IDENTIFIER COLON type_annotation ASSIGN expression .)
    COMMA           reduce using rule 140 (parameter -> IDENTIFIER COLON type_annotation ASSIGN expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 322

    (115) else_if_statement -> ELSE IF expression LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement_list                 shift and go to state 332
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 323

    (110) if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    LET             reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    VAR             reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    SELF            reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FOR             reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    NOT             reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    STRING          reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    NIL             reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    $end            reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)
    CASE            reduce using rule 110 (if_statement -> IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE .)


state 324

    (112) if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 333
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 325

    (125) case_clause -> CASE case_patterns COLON optional_newlines . case_body
    (130) optional_newlines -> optional_newlines . NEWLINE
    (126) case_body -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 328
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    case_body                      shift and go to state 334
    statement_list                 shift and go to state 329
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 326

    (127) case_patterns -> case_patterns COMMA expression .
    (46) expression -> expression . LBRACKET expression RBRACKET
    (63) expression -> expression . DOT INT_LITERAL
    (64) expression -> expression . DOT IDENTIFIER
    (75) expression -> expression . PLUS expression
    (76) expression -> expression . MINUS expression
    (77) expression -> expression . TIMES expression
    (78) expression -> expression . DIVIDE expression
    (79) expression -> expression . MODULO expression
    (82) expression -> expression . AND expression
    (83) expression -> expression . OR expression
    (85) expression -> expression . EQ expression
    (86) expression -> expression . NE expression
    (87) expression -> expression . GT expression
    (88) expression -> expression . LT expression
    (89) expression -> expression . GE expression
    (90) expression -> expression . LE expression
    (91) expression -> expression . QUESTION expression COLON expression
    (92) expression -> expression . NIL_COALESCE expression

    COLON           reduce using rule 127 (case_patterns -> case_patterns COMMA expression .)
    COMMA           reduce using rule 127 (case_patterns -> case_patterns COMMA expression .)
    LBRACKET        shift and go to state 53
    DOT             shift and go to state 54
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61
    EQ              shift and go to state 62
    NE              shift and go to state 63
    GT              shift and go to state 64
    LT              shift and go to state 65
    GE              shift and go to state 66
    LE              shift and go to state 67
    QUESTION        shift and go to state 68
    NIL_COALESCE    shift and go to state 69


state 327

    (129) default_case -> DEFAULT COLON optional_newlines case_body .

    RBRACE          reduce using rule 129 (default_case -> DEFAULT COLON optional_newlines case_body .)
    NEWLINE         reduce using rule 129 (default_case -> DEFAULT COLON optional_newlines case_body .)


state 328

    (130) optional_newlines -> optional_newlines NEWLINE .
    (18) statement -> NEWLINE .

  ! reduce/reduce conflict for NEWLINE resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for LET resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for VAR resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for IF resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for GUARD resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for SWITCH resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for RETURN resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for BREAK resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for SELF resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for FOR resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for WHILE resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for FUNC resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for CLASS resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for MINUS resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for PLUS resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for NOT resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for FLOAT_LITERAL resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for STRING resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for TRUE resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for FALSE resolved using rule 18 (statement -> NEWLINE .)
  ! reduce/reduce conflict for NIL resolved using rule 18 (statement -> NEWLINE .)
    NEWLINE         reduce using rule 18 (statement -> NEWLINE .)
    LET             reduce using rule 18 (statement -> NEWLINE .)
    VAR             reduce using rule 18 (statement -> NEWLINE .)
    IF              reduce using rule 18 (statement -> NEWLINE .)
    GUARD           reduce using rule 18 (statement -> NEWLINE .)
    SWITCH          reduce using rule 18 (statement -> NEWLINE .)
    IDENTIFIER      reduce using rule 18 (statement -> NEWLINE .)
    RETURN          reduce using rule 18 (statement -> NEWLINE .)
    BREAK           reduce using rule 18 (statement -> NEWLINE .)
    CONTINUE        reduce using rule 18 (statement -> NEWLINE .)
    SELF            reduce using rule 18 (statement -> NEWLINE .)
    FOR             reduce using rule 18 (statement -> NEWLINE .)
    WHILE           reduce using rule 18 (statement -> NEWLINE .)
    FUNC            reduce using rule 18 (statement -> NEWLINE .)
    CLASS           reduce using rule 18 (statement -> NEWLINE .)
    LBRACKET        reduce using rule 18 (statement -> NEWLINE .)
    LPAREN          reduce using rule 18 (statement -> NEWLINE .)
    MINUS           reduce using rule 18 (statement -> NEWLINE .)
    PLUS            reduce using rule 18 (statement -> NEWLINE .)
    NOT             reduce using rule 18 (statement -> NEWLINE .)
    INT_LITERAL     reduce using rule 18 (statement -> NEWLINE .)
    FLOAT_LITERAL   reduce using rule 18 (statement -> NEWLINE .)
    STRING          reduce using rule 18 (statement -> NEWLINE .)
    TRUE            reduce using rule 18 (statement -> NEWLINE .)
    FALSE           reduce using rule 18 (statement -> NEWLINE .)
    NIL             reduce using rule 18 (statement -> NEWLINE .)
    RBRACE          reduce using rule 18 (statement -> NEWLINE .)
    DEFAULT         reduce using rule 18 (statement -> NEWLINE .)
    CASE            reduce using rule 18 (statement -> NEWLINE .)

  ! NEWLINE         [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! LET             [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! VAR             [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! IF              [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! GUARD           [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! SWITCH          [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! IDENTIFIER      [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! RETURN          [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! BREAK           [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! CONTINUE        [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! SELF            [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! FOR             [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! WHILE           [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! FUNC            [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! CLASS           [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! LBRACKET        [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! LPAREN          [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! MINUS           [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! PLUS            [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! NOT             [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! INT_LITERAL     [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! FLOAT_LITERAL   [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! STRING          [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! TRUE            [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! FALSE           [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]
  ! NIL             [ reduce using rule 130 (optional_newlines -> optional_newlines NEWLINE .) ]


state 329

    (126) case_body -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

  ! shift/reduce conflict for NEWLINE resolved as shift
    RBRACE          reduce using rule 126 (case_body -> statement_list .)
    DEFAULT         reduce using rule 126 (case_body -> statement_list .)
    CASE            reduce using rule 126 (case_body -> statement_list .)
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

  ! NEWLINE         [ reduce using rule 126 (case_body -> statement_list .) ]

    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 330

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET . LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE

    LBRACE          shift and go to state 335


state 331

    (166) method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation .

    LBRACE          reduce using rule 166 (method_header -> FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation .)


state 332

    (115) else_if_statement -> ELSE IF expression LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    RBRACE          shift and go to state 336
    NEWLINE         shift and go to state 18
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    expression                     shift and go to state 21
    statement                      shift and go to state 50
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 333

    (112) if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    LET             reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    VAR             reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    IF              reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    SELF            reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    FOR             reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    NOT             reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    STRING          reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    NIL             reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    $end            reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)
    CASE            reduce using rule 112 (if_statement -> IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE .)


state 334

    (125) case_clause -> CASE case_patterns COLON optional_newlines case_body .

    DEFAULT         reduce using rule 125 (case_clause -> CASE case_patterns COLON optional_newlines case_body .)
    RBRACE          reduce using rule 125 (case_clause -> CASE case_patterns COLON optional_newlines case_body .)
    NEWLINE         reduce using rule 125 (case_clause -> CASE case_patterns COLON optional_newlines case_body .)
    CASE            reduce using rule 125 (case_clause -> CASE case_patterns COLON optional_newlines case_body .)


state 335

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE . optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    NEWLINE         reduce using rule 170 (empty -> .)
    LET             reduce using rule 170 (empty -> .)
    VAR             reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    GUARD           reduce using rule 170 (empty -> .)
    SWITCH          reduce using rule 170 (empty -> .)
    IDENTIFIER      reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    BREAK           reduce using rule 170 (empty -> .)
    CONTINUE        reduce using rule 170 (empty -> .)
    SELF            reduce using rule 170 (empty -> .)
    FOR             reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FUNC            reduce using rule 170 (empty -> .)
    CLASS           reduce using rule 170 (empty -> .)
    LBRACKET        reduce using rule 170 (empty -> .)
    LPAREN          reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    NOT             reduce using rule 170 (empty -> .)
    INT_LITERAL     reduce using rule 170 (empty -> .)
    FLOAT_LITERAL   reduce using rule 170 (empty -> .)
    STRING          reduce using rule 170 (empty -> .)
    TRUE            reduce using rule 170 (empty -> .)
    FALSE           reduce using rule 170 (empty -> .)
    NIL             reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 337
    empty                          shift and go to state 204

state 336

    (115) else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .

    ELSE            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    NEWLINE         reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    LET             reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    VAR             reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    IF              reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    GUARD           reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    SWITCH          reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    SELF            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    FOR             reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    FUNC            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    NOT             reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    INT_LITERAL     reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    FLOAT_LITERAL   reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    STRING          reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    NIL             reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    $end            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    DEFAULT         reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)
    CASE            reduce using rule 115 (else_if_statement -> ELSE IF expression LBRACE statement_list RBRACE .)


state 337

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines . statement_list optional_newlines RBRACE optional_newlines RBRACE
    (130) optional_newlines -> optional_newlines . NEWLINE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

    NEWLINE         shift and go to state 328
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

    statement_list                 shift and go to state 338
    statement                      shift and go to state 3
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 338

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list . optional_newlines RBRACE optional_newlines RBRACE
    (2) statement_list -> statement_list . statement
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (4) statement -> . variable_declaration
    (5) statement -> . assignment
    (6) statement -> . for_statement
    (7) statement -> . if_statement
    (8) statement -> . guard_statement
    (9) statement -> . while_statement
    (10) statement -> . switch_statement
    (11) statement -> . function_declaration
    (12) statement -> . function_call_statement
    (13) statement -> . class_declaration
    (14) statement -> . expression_statement
    (15) statement -> . return_statement
    (16) statement -> . break_statement
    (17) statement -> . continue_statement
    (18) statement -> . NEWLINE
    (170) empty -> .
    (20) variable_declaration -> . LET IDENTIFIER COLON type_annotation ASSIGN expression
    (21) variable_declaration -> . VAR IDENTIFIER COLON type_annotation ASSIGN expression
    (22) variable_declaration -> . LET IDENTIFIER ASSIGN expression
    (23) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (24) variable_declaration -> . LET IDENTIFIER COLON type_annotation
    (25) variable_declaration -> . VAR IDENTIFIER COLON type_annotation
    (26) variable_declaration -> . LET IDENTIFIER COLON tuple_type
    (27) variable_declaration -> . VAR IDENTIFIER COLON tuple_type
    (65) assignment -> . lvalue ASSIGN expression
    (66) assignment -> . lvalue PLUS_ASSIGN expression
    (67) assignment -> . lvalue MINUS_ASSIGN expression
    (68) assignment -> . lvalue TIMES_ASSIGN expression
    (69) assignment -> . lvalue DIV_ASSIGN expression
    (70) assignment -> . lvalue MOD_ASSIGN expression
    (104) for_statement -> . for_header LBRACE statement_list RBRACE
    (109) if_statement -> . IF expression LBRACE statement_list RBRACE
    (110) if_statement -> . IF expression LBRACE statement_list RBRACE ELSE LBRACE statement_list RBRACE
    (111) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain
    (112) if_statement -> . IF expression LBRACE statement_list RBRACE else_if_chain ELSE LBRACE statement_list RBRACE
    (116) guard_statement -> . GUARD expression ELSE LBRACE statement_list RBRACE
    (117) while_statement -> . while_header LBRACE statement_list RBRACE
    (121) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list optional_newlines RBRACE
    (122) switch_statement -> . SWITCH expression LBRACE optional_newlines case_list default_case optional_newlines RBRACE
    (132) function_declaration -> . func_header LBRACE statement_list RBRACE
    (143) function_call_statement -> . IDENTIFIER LPAREN argument_list RPAREN
    (144) function_call_statement -> . IDENTIFIER LPAREN RPAREN
    (147) class_declaration -> . class_header LBRACE class_body RBRACE
    (19) expression_statement -> . expression
    (141) return_statement -> . RETURN expression
    (142) return_statement -> . RETURN
    (119) break_statement -> . BREAK
    (120) continue_statement -> . CONTINUE
    (71) lvalue -> . IDENTIFIER
    (72) lvalue -> . SELF DOT IDENTIFIER
    (73) lvalue -> . lvalue DOT IDENTIFIER
    (74) lvalue -> . lvalue LBRACKET expression RBRACKET
    (105) for_header -> . FOR IDENTIFIER IN range_expression
    (106) for_header -> . FOR IDENTIFIER IN expression
    (118) while_header -> . WHILE expression
    (133) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN ARROW type_annotation
    (134) func_header -> . FUNC IDENTIFIER LPAREN RPAREN ARROW type_annotation
    (135) func_header -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN
    (136) func_header -> . FUNC IDENTIFIER LPAREN RPAREN
    (148) class_header -> . CLASS IDENTIFIER
    (42) expression -> . LBRACKET array_elements RBRACKET
    (43) expression -> . LBRACKET RBRACKET
    (46) expression -> . expression LBRACKET expression RBRACKET
    (48) expression -> . LBRACKET dictionary_pairs RBRACKET
    (49) expression -> . LBRACKET COLON RBRACKET
    (58) expression -> . LPAREN tuple_elements RPAREN
    (63) expression -> . expression DOT INT_LITERAL
    (64) expression -> . expression DOT IDENTIFIER
    (75) expression -> . expression PLUS expression
    (76) expression -> . expression MINUS expression
    (77) expression -> . expression TIMES expression
    (78) expression -> . expression DIVIDE expression
    (79) expression -> . expression MODULO expression
    (80) expression -> . MINUS expression
    (81) expression -> . PLUS expression
    (82) expression -> . expression AND expression
    (83) expression -> . expression OR expression
    (84) expression -> . NOT expression
    (85) expression -> . expression EQ expression
    (86) expression -> . expression NE expression
    (87) expression -> . expression GT expression
    (88) expression -> . expression LT expression
    (89) expression -> . expression GE expression
    (90) expression -> . expression LE expression
    (91) expression -> . expression QUESTION expression COLON expression
    (92) expression -> . expression NIL_COALESCE expression
    (93) expression -> . LPAREN expression RPAREN
    (94) expression -> . INT_LITERAL
    (95) expression -> . FLOAT_LITERAL
    (96) expression -> . STRING
    (97) expression -> . TRUE
    (98) expression -> . FALSE
    (99) expression -> . NIL
    (100) expression -> . IDENTIFIER
    (101) expression -> . SELF DOT IDENTIFIER
    (102) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (103) expression -> . IDENTIFIER LPAREN RPAREN

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 170 (empty -> .)
    LET             shift and go to state 19
    VAR             shift and go to state 22
    IF              shift and go to state 25
    GUARD           shift and go to state 26
    SWITCH          shift and go to state 28
    IDENTIFIER      shift and go to state 20
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    SELF            shift and go to state 35
    FOR             shift and go to state 37
    WHILE           shift and go to state 38
    FUNC            shift and go to state 39
    CLASS           shift and go to state 40
    LBRACKET        shift and go to state 36
    LPAREN          shift and go to state 30
    MINUS           shift and go to state 43
    PLUS            shift and go to state 42
    NOT             shift and go to state 44
    INT_LITERAL     shift and go to state 41
    FLOAT_LITERAL   shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49

  ! NEWLINE         [ reduce using rule 170 (empty -> .) ]

    optional_newlines              shift and go to state 339
    statement                      shift and go to state 50
    empty                          shift and go to state 204
    variable_declaration           shift and go to state 4
    assignment                     shift and go to state 5
    for_statement                  shift and go to state 6
    if_statement                   shift and go to state 7
    guard_statement                shift and go to state 8
    while_statement                shift and go to state 9
    switch_statement               shift and go to state 10
    function_declaration           shift and go to state 11
    function_call_statement        shift and go to state 12
    class_declaration              shift and go to state 13
    expression_statement           shift and go to state 14
    return_statement               shift and go to state 15
    break_statement                shift and go to state 16
    continue_statement             shift and go to state 17
    expression                     shift and go to state 21
    lvalue                         shift and go to state 23
    for_header                     shift and go to state 24
    while_header                   shift and go to state 27
    func_header                    shift and go to state 29
    class_header                   shift and go to state 31

state 339

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines . RBRACE optional_newlines RBRACE
    (130) optional_newlines -> optional_newlines . NEWLINE

    RBRACE          shift and go to state 340
    NEWLINE         shift and go to state 247


state 340

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE . optional_newlines RBRACE
    (130) optional_newlines -> . optional_newlines NEWLINE
    (131) optional_newlines -> . empty
    (170) empty -> .

    RBRACE          reduce using rule 170 (empty -> .)
    NEWLINE         reduce using rule 170 (empty -> .)

    optional_newlines              shift and go to state 341
    empty                          shift and go to state 204

state 341

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines . RBRACE
    (130) optional_newlines -> optional_newlines . NEWLINE

    RBRACE          shift and go to state 342
    NEWLINE         shift and go to state 247


state 342

    (161) computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .

    RBRACE          reduce using rule 161 (computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .)
    NEWLINE         reduce using rule 161 (computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .)
    VAR             reduce using rule 161 (computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .)
    LET             reduce using rule 161 (computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .)
    INIT            reduce using rule 161 (computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .)
    FUNC            reduce using rule 161 (computed_property -> VAR IDENTIFIER COLON type_annotation LBRACE optional_newlines GET LBRACE optional_newlines statement_list optional_newlines RBRACE optional_newlines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 20 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 21 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 21 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 21 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 32 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 32 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 32 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 32 resolved as shift
WARNING: shift/reduce conflict for NOT in state 32 resolved as shift
WARNING: shift/reduce conflict for INT_LITERAL in state 32 resolved as shift
WARNING: shift/reduce conflict for FLOAT_LITERAL in state 32 resolved as shift
WARNING: shift/reduce conflict for STRING in state 32 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 32 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 32 resolved as shift
WARNING: shift/reduce conflict for NIL in state 32 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 32 resolved as shift
WARNING: shift/reduce conflict for SELF in state 32 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 81 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 88 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 91 resolved as shift
WARNING: shift/reduce conflict for VAR in state 91 resolved as shift
WARNING: shift/reduce conflict for LET in state 91 resolved as shift
WARNING: shift/reduce conflict for INIT in state 91 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 91 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 92 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 92 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 92 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 132 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 132 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 132 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 133 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 133 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 136 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 136 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 137 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 194 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 194 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 194 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 203 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 261 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 261 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 261 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 267 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 267 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 267 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 329 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 338 resolved as shift
WARNING: reduce/reduce conflict in state 20 resolved using rule (lvalue -> IDENTIFIER)
WARNING: rejected rule (expression -> IDENTIFIER) in state 20
WARNING: reduce/reduce conflict in state 110 resolved using rule (expression -> IDENTIFIER LPAREN RPAREN)
WARNING: rejected rule (function_call_statement -> IDENTIFIER LPAREN RPAREN) in state 110
WARNING: reduce/reduce conflict in state 166 resolved using rule (lvalue -> SELF DOT IDENTIFIER)
WARNING: rejected rule (expression -> SELF DOT IDENTIFIER) in state 166
WARNING: reduce/reduce conflict in state 177 resolved using rule (variable_declaration -> LET IDENTIFIER COLON tuple_type)
WARNING: rejected rule (type_annotation -> tuple_type) in state 177
WARNING: reduce/reduce conflict in state 188 resolved using rule (expression -> IDENTIFIER LPAREN argument_list RPAREN)
WARNING: rejected rule (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN) in state 188
WARNING: reduce/reduce conflict in state 193 resolved using rule (variable_declaration -> VAR IDENTIFIER COLON tuple_type)
WARNING: rejected rule (type_annotation -> tuple_type) in state 193
WARNING: reduce/reduce conflict in state 278 resolved using rule (type_annotation -> tuple_type)
WARNING: rejected rule (property_declaration -> VAR IDENTIFIER COLON tuple_type) in state 278
WARNING: reduce/reduce conflict in state 280 resolved using rule (type_annotation -> tuple_type)
WARNING: rejected rule (property_declaration -> LET IDENTIFIER COLON tuple_type) in state 280
WARNING: reduce/reduce conflict in state 328 resolved using rule (statement -> NEWLINE)
WARNING: rejected rule (optional_newlines -> optional_newlines NEWLINE) in state 328
WARNING: Rule (function_call_statement -> IDENTIFIER LPAREN RPAREN) is never reduced
WARNING: Rule (function_call_statement -> IDENTIFIER LPAREN argument_list RPAREN) is never reduced
WARNING: Rule (property_declaration -> VAR IDENTIFIER COLON tuple_type) is never reduced
WARNING: Rule (property_declaration -> LET IDENTIFIER COLON tuple_type) is never reduced
